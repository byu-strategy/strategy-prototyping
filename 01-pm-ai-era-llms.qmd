---
title: "AI Product Management"
---

## History of Product Management

At its simplest, product management is about identifying customer needs, aligning them with business goals, and working with cross-functional teams to build products that succeed in the market. The person responsible is the Product Manager (PM), often called the "CEO of the product."

Some people take issue with the “CEO” comparison, since product managers typically influence without formal authority and often don’t have many direct reports. Still, like a CEO, the skills of a product manager are broad and typically include:

-   Strategic thinking – setting vision, making trade-offs, and aligning with business goals
-   Customer insight – understanding user needs and pain points
-   Analytical ability – using data and critical thinking to guide decisions
-   Technical & design fluency – collaborating effectively with engineers and designers
-   Execution & organization – planning roadmaps, prioritizing, and delivering results
-   Communication & leadership – influencing, storytelling, and managing stakeholders

Products can be hardware or software, but since software dominates in volume, product management is often associated with software, even though many of the principles can apply equally well to hardware. Today, many hardware products come with a software component or integrated app, at times blurring the line between hardware and software. The focus of this course is software products that can be built with the assistance of AI.

Product Management, as a formal discipline and job title, traces its roots to Hewlett-Packard in the 1940s, where it emerged as a distinct driver of innovation in technology. Yet the concept predates HP: a 1931 Procter & Gamble memo introduced the role of “Brand Men,” whose responsibilities closely foreshadowed what would later be recognized as Product Management.

![Image source: Wikimedia Commons](images/brand-men.jpg)

Early influences such as the \[Scrum development process\](https://en.wikipedia.org/wiki/Scrum\_(software_development))) and the [Agile Manifesto](https://agilemanifesto.org/) reshaped how products are built, while initiatives like Google’s Associate Product Manager (APM) program and influential books helped standardize best practices. In recent years, PM has become one of the most sought-after careers, and today the field is entering a new era with the rise of the AI Product Manager.

![A History of Product Management; Aakash Gupta and Scott Murff](images/pm-history.png)

The personal computer revolution of the 1980s brought computing into offices and homes. The rise of the internet in the 1990s connected the world and created entirely new industries, from e-commerce to online media. In the 2000s, broadband (i.e. high-speed internet access) and cloud computing made software cheaper to build, scale, and distribute, while the launch of the iPhone in 2007 ushered in the smartphone era putting powerful applications directly into billions of people’s hands.

In 2011, Marc Andreessen, co-founder of the venture capital firm Andreessen Horowitz (a16z) (known for its influential early investments in companies like Facebook, Airbnb, and Coinbase) famously observed that [*Software Is Eating the World*](https://a16z.com/why-software-is-eating-the-world/).

AI now appears to be on track to “eat the world” again, this time at a much faster pace. The launch of ChatGPT on November 30, 2022, marked a turning point, catalyzing mass adoption of generative AI and enabling the rise of the AI Product Manager.

Marc now predicts that [*AI Will Save the World*](https://a16z.com/ai-will-save-the-world/), but this certainly won't happen automatically. Because human nature is what it is, there will be plenty of people using AI in ways that are damaging to both individuals and society. Indeed, we are living in the time when:

> “Discoveries latent with such potent power, either for the blessing or the destruction of human beings as to make men’s responsibility in controlling them the most gigantic ever placed in human hands. … This age is fraught with limitless perils, as well as untold possibilities.” *--David O. McKay, in Conference Report, Oct. 1966, 4.*

**You have the incredibly exciting and challenging opportunity to harness AI to improve the world. This class will help prepare you to seize that opportunity.**

Over the past two decades, many companies adopted a *product trio* team structure for building software products. This structure brings together three complementary roles: the product manager, who defines the vision, strategy, and priorities; the designer, who ensures usability, aesthetics, and a seamless user experience; and one or more engineers, who turn ideas into functional, scalable solutions. By balancing business objectives, user needs, and technical feasibility, the trio has emerged as a proven way to foster cross-functional collaboration and accelerate product development.

AI and the tools we will use in this course are having a major impact and disrupting what had become a stable organizational model. This is true because AI changes both the division of labor within the trio and the speed and scale at which individuals and teams can operate.

## AI Product Management

With AI, a PM can quickly generate wireframes, mockups, or even working product demos without waiting on design or engineering support. Instead of handing off abstract requirements, they can test tangible ideas with users in days, not weeks. This doesn’t eliminate the need for designers and engineers, but it shifts when and how they are engaged. Designers can focus on higher-fidelity experience and brand expression, while engineers concentrate on scalability, integration, and technical soundness.

It remains to be seen how this will fully play out, but early indications suggest that shifts in how PMs, designers, and engineers work together are real and lasting. With the right AI tools some ambitious individuals may be able to wear all three hats to varying degrees.

Below are a selection of anecdotes from leaders in the field that provides some insight into how things are shifting.

::: tweet-center
<blockquote class="twitter-tweet">

<p lang="en" dir="ltr">

Builder’s high is back...

</p>

— Madhu Guru (@realmadhuguru) <a href="https://twitter.com/realmadhuguru/status/1955451011323314641">August 13, 2025</a>

</blockquote>
:::

```{=html}
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
```

::: tweet-center
<blockquote class="twitter-tweet">

<p lang="en" dir="ltr">

We are adding a coding section to all of our Product Managers interviews at <a href="https://twitter.com/Shopify?ref_src=twsrc%5Etfw">@Shopify</a>.<br><br> We'll start with APM interviews. We expect candidates to build a prototype of the product they suggested in the case interview.<br><br> There is no excuse for PMs not building prototypes.

</p>

— Kaz Nejatian (@CanadaKaz) <a href="https://twitter.com/CanadaKaz/status/1955629733460562404?ref_src=twsrc%5Etfw"> August 13, 2025 </a>

</blockquote>
:::

```{=html}
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
```

::: tweet-center
<blockquote class="twitter-tweet">

<p lang="en" dir="ltr">

Vibe coding is here to stay. I'd been worried it might be a fad, but I talked to the founder of an infrastructure company who's in a position to see how well vibe-coded apps are doing, and he said a lot of them are making money.

</p>

— Paul Graham (@paulg) <a href="https://twitter.com/paulg/status/1956458026652799173?ref_src=twsrc%5Etfw"> August 15, 2025 </a>

</blockquote>
:::

```{=html}
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
```

::: embed-center
<iframe src="https://www.linkedin.com/embed/feed/update/urn:li:ugcPost:7362122859722256384?collapsed=1" height="567" width="504" frameborder="0" allowfullscreen title="Embedded post">

</iframe>
:::

![AI Product Management Learning Roadmap from Paweł Huryn](images/ai-pm-roadmap.jpeg)

## Let's Build!

### The Command Line

In order to be a serious AI Product Manager, you need to get comfortable interacting with your computer via the [command line](https://en.wikipedia.org/wiki/Command-line_interface).

The command line is a text-based interface, often called a CLI (Command Line Interface), that lets you control your computer by typing instructions rather than clicking with a mouse, touchpad, or touch screen. You access the command line through a program called a terminal which is a simple black (or white) window with just text, no buttons or icons. On Mac, this program is literally called "Terminal." On Windows, it's called "Command Prompt" or "PowerShell."

Instead of navigating through a graphical user interface (GUI) with windows and icons, you type commands directly into this terminal window and press Enter to execute them. The command line acts as your gateway to the underlying operating system, giving you direct access to files, programs, and system functions that might be buried deep within GUI menus or not available graphically at all.

This approach offers several advantages: greater precision in file operations, faster execution of repetitive tasks, access to powerful automation tools, and the ability to combine simple commands into complex workflows. Developers and data scientists rely on the command line because it's faster and more powerful for tasks like creating projects, installing software, running code, and automating workflows.

**ChatGPT and other LLM-powered generative AI tools have made learning the command line more important, not less.** The command line is where you unlock the real power of automation, enabling you to run scripts and streamline repetitive tasks. Many advanced system administration tasks, programming tools, and server management operations are primarily designed for command-line use, making terminal proficiency essential for developers and savvy product managers.

Furthermore, the command line is the native environment for the industry-leading approach to AI-assisted coding, Claude Code, which we’ll be using throughout this class. By getting comfortable in the command line, you won’t just be learning an obscure developer skill; you’ll be stepping into the same environment where cutting-edge AI coding tools operate, giving you the ability to build, experiment, and ship AI products with confidence.

Now, let's learn the command line by doing. Spend the next 10 minutes testing the following commands.

```{python eval=false}
# What folder am I in?: "print working directory"
pwd

# What files are in this folder?: "list"
ls

# Move around: "change directory"
cd foldername
cd ..            # up one level
cd ~             # home folder

# Make things: “make directory”
mkdir my-project

# Create or overwrite a file with text (cross-platform): “repeat back”
# > is like hitting “Save As” and overwriting the file.
echo "Hello AI PMs" > hello.txt

# Append text (cross-platform)
# >> is like hitting “Add to end” (append) — you’re just tacking on more notes.
echo "Second line" >> hello.txt

# Show file contents
cat notes.txt

# Combine files into a new file
cat part1.txt part2.txt > full.txt

# use cat to peek inside a file without leaving the terminal. If you give it more than one file, it glues them together into a single text stream.

# Copy a file: "copy"
cp notes.txt backup.txt

# Remove things: “remove”
rm hello.txt "
rm -r my-project   # remove a folder (careful!)

# Open applications
open -a "Google Chrome" https://claude.ai

# you can leave file name off if you just wanna open a blank instance.
open -a "Microsoft Word" mydoc.docx

```

#### Gotchas

-   Paths with spaces: quote them — cd "My Folder"
-   Case sensitivity: macOS/Linux are usually case-sensitive; Windows is not.
-   rm is more permanent than dragging something to the Trash/Recycle Bin. By default, it doesn’t send files to a “trash”, it permanently deletes them. Use with caution!

#### Package management

The next concept to tackle on the journey to becoming an AI powered Product Manager is **package management.** This is a tool your computer uses to install, update, and remove software through the command line. Instead of hunting down installers on websites and clicking through “Next, Next, Finish,” a package manager lets you type a single command to get the tool you need. This matters because it saves time, keeps your environment consistent, and makes it easy to update everything at once which is a helpful when building digital products that depend on multiple tools and libraries. Learning to use a package manager puts you in control of your setup, reduces errors, and helps you work like a professional.

On Mac, *Homebrew* is the standard package manager and must be installed. 

For Windows, *Winget* comes pre-installed.

Run the following commands to install and/or check the version of your package manager.

```{python eval=false}
# Mac

# Install Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Confirm installation by checking which version
brew --version
```

```{python eval=false}
# Windows

# winget should be preinstalled on windows
winget --version
```

Winget comes pre-installed on Windows 10 (version 1709+) and Windows 11 so there is generally no need to install it.

### VS Code

Next we'll get set up with Visual Studio Code (VS Code), a free, open-source code editor developed by Microsoft that has become one of the most popular development environments among programmers worldwide. Launched in 2015, VS Code combines the simplicity of a lightweight text editor with powerful IDE-like features including intelligent code completion, debugging capabilities, built-in version control integration, and an extensive marketplace of extensions that can add support for virtually any programming language or development workflow. Its cross-platform availability (Windows, macOS), fast performance, and highly customizable interface have made it a favorite among developers working on everything from web applications to machine learning projects. We will build applications within VS code throughout the semester.

Let's install it via the package manager. 

```{python eval=false}
# Install VS Code using Homebrew
brew install --cask visual-studio-code
```

Note: The --cask flag tells Homebrew to install a GUI application rather than a command-line tool.

```{python eval=false}
# Install VS Code using Windows Package Manager
winget install Microsoft.VisualStudioCode
```

### Claude Code

Claude Code is a command-line tool that enables developers to delegate coding tasks directly to Claude AI from their terminal, creating an agentic coding experience where Claude can autonomously handle complex development workflows. Unlike traditional AI coding assistants that provide suggestions, Claude Code allows Claude to take full ownership of coding tasks, from analyzing requirements and planning implementation to writing, testing, and iterating on code across multiple files and directories. The tool is designed to integrate seamlessly into existing development workflows, allowing developers to describe what they want to build in natural language and have Claude execute the entire development process, including debugging, refactoring, and implementing best practices, while maintaining transparency through detailed logging and the ability for developers to review and approve changes at each step.

{{< video https://www.youtube.com/embed/GqjvaBUk3Tc >}}

### Code your first app

Open VS Code, open the folder where you want to save your application files and start up Claude Code via the terminal within VS Code.

```{python eval=false}
# star-up claude code
claude
```

Turn on Explanatory mode:

```{python eval=false}
# star-up claude code
/output-style explanatory
```

Noticed that this created a .claude file. 

A .claude file is a configuration file used by Claude Code. These files help define project-specific settings and instructions for how Claude should approach coding tasks in your project.

.claude files typically contain:

- Project context and instructions - Information about your project's structure, coding standards, and specific requirements
- File patterns and exclusions - Rules about which files Claude should or shouldn't modify
- Custom prompts and guidelines - Specific instructions for how you want Claude to approach coding tasks in this particular project

These files allow you to give Claude persistent context about your project so you don't have to re-explain your codebase structure, conventions, or preferences every time you use Claude Code. They essentially act as a "memory" for Claude about how to work effectively within your specific project.

Now copy paste in the following prompt into the active Claude Code terminal session:

> Build me a simple todo list app using streamlit

::: {.callout-tip collapse="true" title="How many lines of code does a production grade business application typically require?"}
A production-grade business application for internal use typically ranges from 10,000 to 500,000+ lines of code, depending on several key factors: Small to Medium Internal Apps (10K-50K lines)

Simple CRUD applications with basic workflows Departmental tools with limited integrations Small team usage (10-100 users)

Medium Business Applications (50K-200K lines)

Multi-module systems with complex business logic Integration with several external systems Company-wide usage (100-1000+ users) Advanced reporting and analytics features

Large Enterprise Applications (200K-1M+ lines)

Comprehensive business management systems Extensive integrations and APIs Multi-tenant or highly scalable architectures Complex compliance and security requirements

Factors that significantly impact size:

-   Complexity of business logic - Financial calculations, approval workflows, etc.

-   Number of integrations - APIs, databases, third-party services

-   User interface sophistication - Simple forms vs. rich dashboards Technology stack - Some frameworks require more boilerplate code

-   Code quality practices - Well-structured code with proper separation of concerns Testing coverage - Test code can represent 30-50% of total codebase

Modern considerations: Many internal applications today leverage low-code platforms, cloud services, and existing frameworks, which can reduce custom code requirements significantly. A modern internal app might accomplish what previously took 100K lines with just 20-30K lines by using pre-built components and services.
:::

### Code your second app

Spend the next 15 minutes coming up with another application. For simplicity for now, continue using streamlit (i.e. include in your prompt that the application should be built using streamlit).

## Student Demos

Let's see some of the apps that you built.

