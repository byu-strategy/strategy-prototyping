[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "",
    "text": "Syllabus\nFALL 2025\nThere are two sections of this course being taught under two different. Please note the details for your section.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Prerequisites",
    "text": "Prerequisites\nIS 201 - Introduction to Information Systems OR similar. Students should have an interest in going deep on a technical level and learning to code with assistance from AI.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#required-materials",
    "href": "index.html#required-materials",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Required Materials",
    "text": "Required Materials\nA modern Laptop or desktop (Mac or Windows): - Operating Systems: macOS 10.15+ or Windows 10+ - Hardware: 4GB+ RAM (more is better)\nAI Tools: - We will be using Claude Code throughout the course. Using Claude Code requires a paid Claude account (~$20 per month for the duration of the semester). Your total cost will be about $85 after tax - Gemini is free for students this year:\nInnovators DNAs Resources and Assessment (special reduced price of $20)\nAll other materials are available online at no cost.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#description",
    "href": "index.html#description",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Description",
    "text": "Description\nProduct Management/Creating Digital Products with AI: Strategy & Prototyping immerses students in the evolving role of product managers in the era of AI-enabled innovation. This course combines strategic thinking with hands-on experimentation, giving students both the frameworks and the technical skills to envision, prototype, and launch AI-enhanced digital products.\nStudents will explore foundational concepts in product strategy, customer-centric design, and rapid iteration while learning how AI is transforming each stage of the product lifecycle. Core topics include identifying unmet customer needs, defining and validating minimum viable products (MVPs), accelerating prototyping, and gathering actionable user feedback.\nIn addition to standard product management tools such as GitHub, Jira, and Figma, students will work extensively with cutting-edge AI tools like Lovable, Replit, Cursor, and Claude Code. These tools enable them to ideate, design, and build at unprecedented speed, while gaining an understanding of how AI blurs traditional boundaries between product management, engineering, and design.\nBy the end of the semester, students will have developed, tested, and refined an AI-enabled product.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#purpose",
    "href": "index.html#purpose",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Purpose",
    "text": "Purpose\nThis course develops students’ ability to integrate strategic thinking and technical execution to deliver products that create genuine value for others.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\n\n\n\n\n\n\n\nLearning Outcome\nSupported BYU Aims\n\n\n\n\n1. Understand the basics of how LLMs generate natural language.\nIntellectually Enlarging\n\n\n2. Develop and articulate a product strategy.\nIntellectually Enlarging, Lifelong Learning and Service\n\n\n3. Analyze the physical, mental, and spiritual impact your product is likely to have on its users.\nSpiritually Strengthening, Character Building, Lifelong Learning and Service\n\n\n4. Create a digital product that delivers enduring value to a target customer group.\nIntellectually Enlarging, Lifelong Learning and Service",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#instructor-bio",
    "href": "index.html#instructor-bio",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Instructor Bio",
    "text": "Instructor Bio\nScott Murff is an Associate Teaching Professor of Strategy at the BYU Marriott School of Business, where he also serves as program director and teaches courses on business strategy, decision-making, and artificial intelligence. He brings over 15 years of experience at the intersection of business and technology, having worked as a consultant, product manager, and data scientist.\nPrior to joining BYU, Scott spent nearly seven years at McKinsey & Company in roles ranging from analytics specialist consultant to principal product manager, where he led product development and performance management initiatives for Fortune 500 clients. His earlier career includes building forecasting models as a VP at Zions Bancorporation and conducting regulatory research at the U.S. Office of the Comptroller of the Currency.\nScott holds a Master’s degree in Management Science & Engineering from Stanford University and a B.A. in Economics with a minor in Math, from BYU. He is passionate about helping students apply AI, analytics, and strategy to meaningful real-world problems with both rigor and purpose.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Schedule",
    "text": "Schedule\nSee the Schedule section for a weekly schedule of class topics, assignments, due dates, etc.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#grading",
    "href": "index.html#grading",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Grading",
    "text": "Grading\nBelow is the grading breakdown for each assessment in the course. Each point is weighted equally.\n\n\n\nType\nDescription1\n% of Grade\nPoints\nLearning Outcome(s) Assessed\n\n\n\n\nExam\nPre-Course Knowledge Check2\n0%\n0\n1,2,3,4\n\n\nExam\nFinal Exam\n10%\n50\n1,2,3,4\n\n\nQuiz\nQuiz 1 - AI Product Management\n2%\n10\n1\n\n\nQuiz\nQuiz 2 - LLMs 2\n2%\n10\n1\n\n\nQuiz\nQuiz 3 - Product Strategy and Innovation\n2%\n10\n2\n\n\nQuiz\nQuiz 4 - Customer Validation\n2%\n10\n2\n\n\nQuiz\nQuiz 5 - Mid-semester Feedback Survey\n2%\n10\n\n\n\nQuiz\nQuiz 6 - GitHub and Collaboration\n2%\n10\n4\n\n\nQuiz\nQuiz 7 - APIs and How the Internet Works\n2%\n10\n4\n\n\nQuiz\nQuiz 8 - Principles of Software Engineering and Design\n2%\n10\n4\n\n\nQuiz\nQuiz 9 - AI Tools\n2%\n10\n4\n\n\nQuiz\nQuiz 10 - Product Metrics and Data Analysis\n2%\n10\n4\n\n\nHomework\nHomework 1 – Understanding Large Language Models\n8%\n40\n1\n\n\nHomework\nHomework 2 – Creating a Product Requirements Document (PRD)\n8%\n40\n2, 3\n\n\nHomework\nHomework 3 – Understanding the internet and APIs\n8%\n40\n4\n\n\nHomework\nHomework 4 – Using Git for collaboration and version control\n8%\n40\n4\n\n\nHomework\nHomework 5 – Choosing the right AI tools\n8%\n40\n4\n\n\nProject\nFinal Project\n30%\n150\n4\n\n\n\nTOTAL\n100%\n500\n\n\n\n\n\nNotes:\n\nCompletion of the Pre-Course Knowledge Check is required but does not affect your grade.\nAll assignments and quizzes are described in detail in Assessments section.\n\n\nThe course is not graded on a curve. It’s possible for every student to earn an A.\nAchieving an A is challenging and reflects real commitment and excellence.\nThe grading scale is show below:\n\n\n\nLetter Grade\nPercentage Range\nGPA\n\n\n\n\nA\n93–100%\n4.0\n\n\nA-\n90–92%\n3.7\n\n\nB+\n87–89%\n3.4\n\n\nB\n83–86%\n3.0\n\n\nB-\n80–82%\n2.7\n\n\nC+\n77–79%\n2.4\n\n\nC\n73–76%\n2.0\n\n\nC-\n70–72%\n1.7\n\n\nD+\n67–69%\n1.4\n\n\nD\n63–66%\n1.0\n\n\nD-\n60–62%\n0.7\n\n\nE (Fail)\nBelow 60%\n0.0\n\n\n\n\nLate work policy\nQuizzes: By their nature, in-class quizzes cannot be accepted late.\nHomework: May be turned in up to 9 days late for partial credit with a 10% penalty per day according to the following schedule:\n\n\n\nDays Late\nLate Penalty\n\n\n\n\n1\n-10%\n\n\n2\n-20%\n\n\n3\n-30%\n\n\n4\n-40%\n\n\n5\n-50%\n\n\n6\n-60%\n\n\n7\n-70%\n\n\n8\n-80%\n\n\n9\n-90%\n\n\n10\nNo Credit\n\n\n\nFinal Project: The Final Project must be submitted by 11:59pm on the day of our final class period. Final Projects cannot be turned in late for credit.\nFinal Exam: The Final Exam must be completed by the scheduled time. Final Exams cannot be taken late.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#classroom-culture",
    "href": "index.html#classroom-culture",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Classroom Culture",
    "text": "Classroom Culture\n\nMission and Aims\nThe mission of Brigham Young University — founded, supported, and guided by The Church of Jesus Christ of Latter-day Saints — is to assist individuals in their quest for perfection and eternal life. That assistance should provide a period of intensive learning in a stimulating setting where a commitment to excellence is expected and the full realization of human potential is pursued.\nBYU seeks to develop students of faith, intellect, and character who have the skills and the desire to continue learning and to serve others throughout their lives.\nA BYU education should be (1) spiritually strengthening, (2) intellectually enlarging, and (3) character building, leading to (4) lifelong learning and service.\nBuilding on the foundational Mission and Aims, the Marriott School of Business aspires to transform the world through Christlike leadership by developing leaders of faith, intellect, and character guided by the following 4 values:\n\nFaith in Christ - We value deep and abiding faith in Jesus Christ. Our faith gives us the capacity to envision a better future, the confidence to make that future happen, and the courage to act in the face of challenges.\nIntegrity in Action - We value integrity and hold ourselves to the highest moral and ethical standards. Acting with integrity builds trust, strengthens character, and focuses our ambitions on things of eternal consequence.\nRespect for All - We value respect for all individuals as children of God and recognize the inherent worth, divine potential, and agency of each person. A climate of respect and belonging enhances our learning, facilitates collaboration, and encourages personal growth.\nExcellence - We value excellence in learning, teaching, research, management, and leadership. An expectation of excellence magnifies our influence and motivates us to continually improve.\n\nWe evaluate our decisions and actions by the impact they will have on the academic experience, professional preparation, character development, emotional well-being, and spiritual growth of our students.\n\nPrayer in class\nWe will begin each class with prayer. Each class member is invited to be voice for the prayer at least once throughout the semester. The TAs will reach out prior to class to invite you to pray on a particular day. If you’d rather not be voice for a prayer please let me know on the first day of class so I can instruct the TAs accordingly.\n\n\nLaptop Policy\nYou may use laptops in class for note taking or other class related purposes. Laptops should not be used for activities that would be a distraction to nearby students when your screen is in their line of sight (e.g. sports, instagram, etc.)\n\n\nCold Calling\nI teach in a conversational discussion based style, which includes cold calling students to ask for your input or to pose questions. If you’d rather I not cold call on you please let me know on the first day of class so that I can avoid doing so. I have deep respect for individual learning styles and will make accommodations when needed.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#getting-help",
    "href": "index.html#getting-help",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Getting Help",
    "text": "Getting Help\nThe following resources are available to get help:\n\nStart with AI chat bots and the course website to see if they can assist\nUse the course Slack channel to ask classmates for help\nAttend TA or Professor office hours\nUse Slack or email to contact one of the course TAs\nUse Slack or email to contact Professor Murff",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#honor-code",
    "href": "index.html#honor-code",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Honor Code",
    "text": "Honor Code\nIn keeping with the principles of the BYU Honor Code, students are expected to be honest in all of their academic work. Academic honesty means, most fundamentally, that any work you present as your own must in fact be your own work and not that of another. Violations of this principle may result in a failing grade in the course and additional disciplinary action by the university. Students are also expected to adhere to the Dress and Grooming Standards. Adherence demonstrates respect for yourself and others and ensures an effective learning and working environment. It is the university’s expectation, and every instructor’s expectation in class, that each student will abide by all Honor Code standards. Please call the Honor Code Office at 422-2847 if you have questions about those standards.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#preventing-responding-to-sexual-misconduct",
    "href": "index.html#preventing-responding-to-sexual-misconduct",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Preventing & Responding to Sexual Misconduct",
    "text": "Preventing & Responding to Sexual Misconduct\nThe health and well-being of students is of paramount importance at Brigham Young University. If you or someone you know has experienced sexual harassment (including sexual violence), there are many resources available for assistance.\nIn accordance with Title IX of the Education Amendments of 1972, BYU prohibits unlawful sex discrimination, including sexual harassment, against any participant in its education programs or activities. The university also prohibits sexual harassment by its personnel and students. Sexual harassment occurs when\na person is subjected to unwelcome sexual speech or conduct so severe, pervasive, and offensive that it effectively denies their ability to access any BYU education program or activity; any aid, benefit, or service of BYU is conditioned on a person’s participation in unwelcome sexual conduct; or a person suffers sexual assault, dating violence, domestic violence, or stalking on the basis of sex. University policy requires all faculty members to promptly report incidents of sexual harassment that come to their attention in any way, including through face-to-face conversations, a written class assignment or paper, class discussion, email, text, or social media post. Incidents of sexual harassment should be reported to the Title IX Coordinator at t9coordinator@byu.edu or (801) 422-8692 or 1085 WSC. Reports may also be submitted online at https://titleix.byu.edu/report or 1-888-238-1062 (24-hours a day).\nBYU offers confidential resources for those affected by sexual harassment, including the university’s Sexual Assault Survivor Advocate, as well as a number of non-confidential resources and services that may be helpful. Additional information about Title IX, the university’s Sexual Harassment Policy, reporting requirements, and resources can be found at http://titleix.byu.edu or by contacting the university’s Title IX Coordinator.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "index.html#student-disability",
    "href": "index.html#student-disability",
    "title": "MSB 341 - Product Management / STRAT 490R - Creating Digital Products with AI: Strategy & Prototyping",
    "section": "Student Disability",
    "text": "Student Disability\nBrigham Young University is committed to providing a working and learning atmosphere that reasonably accommodates qualified persons with disabilities. A disability is a physical or mental impairment that substantially limits one or more major life activities. Whether an impairment is substantially limiting depends on its nature and severity, its duration or expected duration, and its permanent or expected permanent or long-term impact. Examples include vision or hearing impairments, physical disabilities, chronic illnesses, emotional disorders (e.g., depression, anxiety), learning disorders, and attention disorders (e.g., ADHD). If you have a disability which impairs your ability to complete this course successfully, please contact the University Accessibility Center (UAC), 2170 WSC or 801-422-2767 to request a reasonable accommodation. The UAC can also assess students for learning, attention, and emotional concerns. If you feel you have been unlawfully discriminated against on the basis of disability, please contact the Equal Opportunity Office at 801-422-5895, eo_manager@byu.edu, or visit https://hrs.byu.edu/equal-opportunity for help.”",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "00-schedule.html",
    "href": "00-schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Below is the planned daily schedule. Dates, topics, and assignments may adjust as needed. All readings, slides, and homework are linked here.\nMake sure to\n\n\n\nWeek\nDates for MSB 341\nDates for STRAT 490R\nTopics\nIn-class Quiz\nHomework Assigned\nMSB 341 Homework Due Date\nSTRAT 490R Homework Due Date\n\n\n\n\n1\nMon, Sept 8\nFri, Sept 5\nCourse overview, Product Management and AI, Thought Leaders, Computer Setup,\n–\n–\n\n–\n\n\n2\nMon, Sept 15\nFri, Sept 12\nLLMs continued, Prompt engineering\nQuiz 1 - AI Product Management\nHW 1 - Understanding Large Language Models\nMon, Sept 29\nFri, Sept 26\n\n\n3\nMon, Sept 15\nFri, Sept 19\nGuest Speaker: Carlos Kemeny. Product Innovation Process, Target Market, Customer Discovery\nQuiz 2 - LLMs 2\n–\n\n–\n\n\n4\nMon, Sept 29\nFri, Sept 26\nValue prop design, hypothesize customer needs/unfulfilled jobs, customer pain/gain. Principles for choosing problems to work on. Validate customer needs\nQuiz 3 - Product Strategy and Innovation\nHW 2 - Creating a Product Requirements Document (PRD)\nMon, Oct 13\nFri, Oct 10\n\n\n5\nMon, Oct 6\nFri, Oct 3\nProject Management with Jira, Backlog, user stories\nQuiz 4 - Customer Validation\n–\n\n–\n\n\n6\nMon, Oct 13\nFri, Oct 10\nGit/GitHub - Collaboration across PM, Eng, Design, Psychological safety, The triad and how it’s changing (ratios of PMs to engineers)\nQuiz 5 - Mid-semester Feedback Survey\nHW 3 - Understanding the internet and APIs\nMon, Oct 27\nFri, Oct 24\n\n\n7\nMon, Oct 20\nFri, Oct 17\nInternet fundamentals · APIs · JSON & HTTP requests\nQuiz 6 - GitHub and Collaboration\n–\n\n–\n\n\n8\nMon, Oct 27\nFri, Oct 24\nPrinciples of software engineering & Design\nQuiz 7 - APIs and How the Internet Works\nHW 4 - Using Git for collaboration and version control\nMon, Nov 17\nFri, Nov 14\n\n\n9\nMon, Nov 3\nFri, Oct 31\nV0, Bolt, Replit, Lovable, Cursor, Windsurf (homework: Build the same app in 5 platforms. Write up what you could do in each. Limitations.)\nQuiz 8 - Principles of Software Engineering and Design\n–\n\n–\n\n\n10\nMon, Nov 10\nFri, Nov 7\nBuild and feedback 1\nQuiz 9 - AI Tools\nHW 5 - Choosing the right AI tools\nMon, Nov 24\nFri, Nov 21\n\n\n11\nMon, Nov 17\nFri, Nov 14\nProduct metrics\nQuiz 10 - Product Metrics and Data Analysis\n–\n\n–\n\n\n12\nMon, Nov 24\nFri, Nov 21\nBuild and feedback 2\n–\n–\n\n–\n\n\n13\nMon, Dec 1\nFri, Nov 28\nNo class – Thanksgiving\n–\n–\n\n–\n\n\n14\nMon, Dec 8\nFri, Dec 5\nFinal Presentations · Reflections\n–\nExtra Credit - Student Ratings\nFinal Project Due\nFinal Project Due\n\n\n15\nMon, Dec 15\nFri, Dec 12\nFinal Exam (50 questions, multiple choice, testing center)\n–\n–\n\n–",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Schedule</span>"
    ]
  },
  {
    "objectID": "00-assessments.html",
    "href": "00-assessments.html",
    "title": "Assessments",
    "section": "",
    "text": "List of All Assessments\nThe following assessments will be used to measure progress towards learning outcomes and to assign grades.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assessments</span>"
    ]
  },
  {
    "objectID": "00-assessments.html#list-of-all-assessments",
    "href": "00-assessments.html#list-of-all-assessments",
    "title": "Assessments",
    "section": "",
    "text": "Type\nDescription\n% of Grade\nPoints\nLearning Outcome(s) Assessed1\n\n\n\n\nExam\nPre-Course Knowledge Check\n0%\n0\n1,2,3,4\n\n\nExam\nFinal Exam\n10%\n50\n1,2,3,4\n\n\nQuiz\nQuiz 1 - AI Product Management\n2%\n10\n1\n\n\nQuiz\nQuiz 2 - LLMs 2\n2%\n10\n1\n\n\nQuiz\nQuiz 3 - Product Strategy and Innovation\n2%\n10\n2\n\n\nQuiz\nQuiz 4 - Customer Validation\n2%\n10\n2\n\n\nQuiz\nQuiz 5 - Mid-semester Feedback Survey\n2%\n10\n\n\n\nQuiz\nQuiz 6 - GitHub and Collaboration\n2%\n10\n4\n\n\nQuiz\nQuiz 7 - APIs and How the Internet Works\n2%\n10\n4\n\n\nQuiz\nQuiz 8 - Principles of Software Engineering and Design\n2%\n10\n4\n\n\nQuiz\nQuiz 9 - AI Tools\n2%\n10\n4\n\n\nQuiz\nQuiz 10 - Product Metrics and Data Analysis\n2%\n10\n4\n\n\nHomework\nHomework 1 – Understanding Large Language Models\n8%\n40\n1\n\n\nHomework\nHomework 2 – Creating a Product Requirements Document (PRD)\n8%\n40\n2, 3\n\n\nHomework\nHomework 3 – Understanding the internet and APIs\n8%\n40\n4\n\n\nHomework\nHomework 4 – Using Git for collaboration and version control\n8%\n40\n4\n\n\nHomework\nHomework 5 – Choosing the right AI tools\n8%\n40\n4\n\n\nProject\nFinal Project\n30%\n150\n4\n\n\n\nTOTAL\n100%\n500\n\n\n\n\n\nNotes\n\nTable of Learning Outcomes\n\n\n\n\n\n\n\n\nLearning Outcome\nSupported BYU Aims\n\n\n\n\n1. Understand the basics of how LLMs generate natural language.\nIntellectually Enlarging\n\n\n2. Develop and articulate a product strategy.\nIntellectually Enlarging, Lifelong Learning and Service\n\n\n3. Analyze the physical, mental, and spiritual impact your product is likely to have on its users.\nSpiritually Strengthening, Character Building, Lifelong Learning and Service\n\n\n4. Create a digital product that delivers value to a target customer group.\nIntellectually Enlarging, Lifelong Learning and Service",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assessments</span>"
    ]
  },
  {
    "objectID": "00-assessments.html#exams",
    "href": "00-assessments.html#exams",
    "title": "Assessments",
    "section": "Exams",
    "text": "Exams\n\nPre-Course Knowledge Check\nThe pre-course knowledge check is a 50 question multiple-choice exam. It does not count towards your grade but is required for you to complete. The purpose of the knowledge check is to understand your baseline level knowledge coming into the class.\nComplete the exam on LearningSuite.\nDo not use AI or any outside resources while completing the exam. Doing so would defeat its purpose and failed to give an accurate signal on base level knowledge.\nThe final exam will be very similar in content and structure and will be completed in the testing center.\nHence, comparing your final exam score to your score on the pre-course knowledge check will give you a good sense for what you have learned in the course.\n\n\nFinal Exam",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assessments</span>"
    ]
  },
  {
    "objectID": "00-assessments.html#homework",
    "href": "00-assessments.html#homework",
    "title": "Assessments",
    "section": "Homework",
    "text": "Homework\n\nHomework 1 – Understanding Large Language Models\n\n\nHomework 2 – Creating a Product Requirements Document (PRD)\n\n\nHomework 3 – Understanding the internet and APIs\n\n\nHomework 4 – Using Git for collaboration and version control\n\n\nHomework 5 – Choosing the right AI tools",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assessments</span>"
    ]
  },
  {
    "objectID": "00-assessments.html#quizzes",
    "href": "00-assessments.html#quizzes",
    "title": "Assessments",
    "section": "Quizzes",
    "text": "Quizzes\nAll quizzes are given during class and will consist of five questions drawn from the associated readings and displayed on the projector. Responses will be written on a note card and turned in during class. Smartphones and laptops or any other aids are not allowed during the quizzes. The purpose of these quizzes is to assess your unaided understanding of the course material.\nA list of the quiz dates and associated readings are shown on the course schedule.",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assessments</span>"
    ]
  },
  {
    "objectID": "00-assessments.html#final-project",
    "href": "00-assessments.html#final-project",
    "title": "Assessments",
    "section": "Final Project",
    "text": "Final Project",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assessments</span>"
    ]
  },
  {
    "objectID": "00-assessments.html#feedback-surveys",
    "href": "00-assessments.html#feedback-surveys",
    "title": "Assessments",
    "section": "Feedback Surveys",
    "text": "Feedback Surveys\n\nMid-Semester Feedback Survey\n\n\nCourse Student Ratings",
    "crumbs": [
      "Course Information",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Assessments</span>"
    ]
  },
  {
    "objectID": "01-pm-ai-era.html",
    "href": "01-pm-ai-era.html",
    "title": "AI Product Management",
    "section": "",
    "text": "History of Product Management\nAt its simplest, product management is about identifying customer needs, aligning them with business goals, and working with cross-functional teams to build products that succeed in the market. The person responsible is the Product Manager (PM), often called the “CEO of the product.”\nSome people take issue with the “CEO” comparison, since product managers typically influence without formal authority and often don’t have many direct reports. Still, like a CEO, the skills of a product manager are broad and typically include:\nProducts can be hardware or software, but since software dominates in volume, product management is often associated with software, even though many of the principles can apply equally well to hardware. Today, many hardware products come with a software component or integrated app, at times blurring the line between hardware and software. The focus of this course is software products that can be built with the assistance of AI.\nProduct Management, as a formal discipline and job title, traces its roots to Hewlett-Packard in the 1940s, where it emerged as a distinct driver of innovation in technology. Yet the concept predates HP: a 1931 Procter & Gamble memo introduced the role of “Brand Men,” whose responsibilities closely foreshadowed what would later be recognized as Product Management.\nEarly influences such as the [Scrum development process](https://en.wikipedia.org/wiki/Scrum_(software_development))) and the Agile Manifesto reshaped how products are built, while initiatives like Google’s Associate Product Manager (APM) program and influential books helped standardize best practices. In recent years, PM has become one of the most sought-after careers, and today the field is entering a new era with the rise of the AI Product Manager.\nThe personal computer revolution of the 1980s brought computing into offices and homes. The rise of the internet in the 1990s connected the world and created entirely new industries, from e-commerce to online media. In the 2000s, broadband (i.e. high-speed internet access) and cloud computing made software cheaper to build, scale, and distribute, while the launch of the iPhone in 2007 ushered in the smartphone era putting powerful applications directly into billions of people’s hands.\nIn 2011, Marc Andreessen, co-founder of the venture capital firm Andreessen Horowitz (a16z) (known for its influential early investments in companies like Facebook, Airbnb, and Coinbase) famously observed that Software Is Eating the World.\nAI now appears to be on track to “eat the world” again, this time at a much faster pace. The launch of ChatGPT on November 30, 2022, marked a turning point, catalyzing mass adoption of generative AI and enabling the rise of the AI Product Manager.\nMarc now predicts that AI Will Save the World, but this certainly won’t happen automatically. Because human nature is what it is, there will be plenty of people using AI in ways that are damaging to both individuals and society. Indeed, we are living in the time when:\nYou have the incredibly exciting and challenging opportunity to harness AI to improve the world. This class will help prepare you to seize that opportunity.\nOver the past two decades, many companies adopted a product trio team structure for building software products. This structure brings together three complementary roles: the product manager, who defines the vision, strategy, and priorities; the designer, who ensures usability, aesthetics, and a seamless user experience; and one or more engineers, who turn ideas into functional, scalable solutions. By balancing business objectives, user needs, and technical feasibility, the trio has emerged as a proven way to foster cross-functional collaboration and accelerate product development.\nAI and the tools we will use in this course are having a major impact and disrupting what had become a stable organizational model. This is true because AI changes both the division of labor within the trio and the speed and scale at which individuals and teams can operate.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>AI Product Management</span>"
    ]
  },
  {
    "objectID": "01-pm-ai-era.html#history-of-product-management",
    "href": "01-pm-ai-era.html#history-of-product-management",
    "title": "AI Product Management",
    "section": "",
    "text": "Strategic thinking – setting vision, making trade-offs, and aligning with business goals\nCustomer insight – understanding user needs and pain points\nAnalytical ability – using data and critical thinking to guide decisions\nTechnical & design fluency – collaborating effectively with engineers and designers\nExecution & organization – planning roadmaps, prioritizing, and delivering results\nCommunication & leadership – influencing, storytelling, and managing stakeholders\n\n\n\n\n\n\nImage source: Wikimedia Commons\n\n\n\n\n\n\nA History of Product Management; Aakash Gupta and Scott Murff\n\n\n\n\n\n\n\n“Discoveries latent with such potent power, either for the blessing or the destruction of human beings as to make men’s responsibility in controlling them the most gigantic ever placed in human hands. … This age is fraught with limitless perils, as well as untold possibilities.” –David O. McKay, in Conference Report, Oct. 1966, 4.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>AI Product Management</span>"
    ]
  },
  {
    "objectID": "01-pm-ai-era.html#ai-product-management",
    "href": "01-pm-ai-era.html#ai-product-management",
    "title": "AI Product Management",
    "section": "AI Product Management",
    "text": "AI Product Management\nWith AI, a PM can quickly generate wireframes, mockups, or even working product demos without waiting on design or engineering support. Instead of handing off abstract requirements, they can test tangible ideas with users in days, not weeks. This doesn’t eliminate the need for designers and engineers, but it shifts when and how they are engaged. Designers can focus on higher-fidelity experience and brand expression, while engineers concentrate on scalability, integration, and technical soundness.\nIt remains to be seen how this will fully play out, but early indications suggest that shifts in how PMs, designers, and engineers work together are real and lasting. With the right AI tools some ambitious individuals may be able to wear all three hats to varying degrees.\nBelow are a selection of anecdotes from leaders in the field that provides some insight into how things are shifting.\n\n\n\nBuilder’s high is back…\n\n— Madhu Guru ((realmadhuguru?)) August 13, 2025\n\n\n\n\n\n\nWe are adding a coding section to all of our Product Managers interviews at (Shopify?). We’ll start with APM interviews. We expect candidates to build a prototype of the product they suggested in the case interview. There is no excuse for PMs not building prototypes.\n\n— Kaz Nejatian ((CanadaKaz?))  August 13, 2025 \n\n\n\n\n\n\nVibe coding is here to stay. I’d been worried it might be a fad, but I talked to the founder of an infrastructure company who’s in a position to see how well vibe-coded apps are doing, and he said a lot of them are making money.\n\n— Paul Graham ((paulg?))  August 15, 2025 \n\n\n\n\n\n\n\n\n\n\nAI Product Management Learning Roadmap from Paweł Huryn",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>AI Product Management</span>"
    ]
  },
  {
    "objectID": "01-pm-ai-era.html#lets-build",
    "href": "01-pm-ai-era.html#lets-build",
    "title": "AI Product Management",
    "section": "Let’s Build!",
    "text": "Let’s Build!\n\nThe Command Line\nIn order to be a serious AI Product Manager, you need to get comfortable interacting with your computer via the command line.\nThe command line is a text-based interface, often called a CLI (Command Line Interface), that lets you control your computer by typing instructions rather than clicking with a mouse, touchpad, or touch screen. You access the command line through a program called a terminal which is a simple black (or white) window with just text, no buttons or icons. On Mac, this program is literally called “Terminal.” On Windows, it’s called “Command Prompt” or “PowerShell.”\nInstead of navigating through a graphical user interface (GUI) with windows and icons, you type commands directly into this terminal window and press Enter to execute them. The command line acts as your gateway to the underlying operating system, giving you direct access to files, programs, and system functions that might be buried deep within GUI menus or not available graphically at all.\nThis approach offers several advantages: greater precision in file operations, faster execution of repetitive tasks, access to powerful automation tools, and the ability to combine simple commands into complex workflows. Developers and data scientists rely on the command line because it’s faster and more powerful for tasks like creating projects, installing software, running code, and automating workflows.\nChatGPT and other LLM-powered generative AI tools have made learning the command line more important, not less. The command line is where you unlock the real power of automation, enabling you to run scripts and streamline repetitive tasks. Many advanced system administration tasks, programming tools, and server management operations are primarily designed for command-line use, making terminal proficiency essential for developers and savvy product managers.\nFurthermore, the command line is the native environment for the industry-leading approach to AI-assisted coding, Claude Code, which we’ll be using throughout this class. By getting comfortable in the command line, you won’t just be learning an obscure developer skill; you’ll be stepping into the same environment where cutting-edge AI coding tools operate, giving you the ability to build, experiment, and ship AI products with confidence.\nNow, let’s learn the command line by doing. Spend the next 10 minutes testing the following commands.\n\n# What folder am I in?: \"print working directory\"\npwd\n\n# What files are in this folder?: \"list\"\nls\n\n# Move around: \"change directory\"\ncd foldername\ncd ..            # up one level\ncd ~             # home folder\n\n# Make things: “make directory”\nmkdir my-project\n\n# Create or overwrite a file with text (cross-platform): “repeat back”\n# &gt; is like hitting “Save As” and overwriting the file.\necho \"Hello AI PMs\" &gt; hello.txt\n\n# Append text (cross-platform)\n# &gt;&gt; is like hitting “Add to end” (append) — you’re just tacking on more notes.\necho \"Second line\" &gt;&gt; hello.txt\n\n# Show file contents\ncat notes.txt\n\n# Combine files into a new file\ncat part1.txt part2.txt &gt; full.txt\n\n# use cat to peek inside a file without leaving the terminal. If you give it more than one file, it glues them together into a single text stream.\n\n# Copy a file: \"copy\"\ncp notes.txt backup.txt\n\n# Remove things: “remove”\nrm hello.txt \"\nrm -r my-project   # remove a folder (careful!)\n\n# Open applications\nopen -a \"Google Chrome\" https://claude.ai\n\n# you can leave file name off if you just wanna open a blank instance.\nopen -a \"Microsoft Word\" mydoc.docx\n\n\nGotchas\n\nPaths with spaces: quote them — cd “My Folder”\nCase sensitivity: macOS/Linux are usually case-sensitive; Windows is not.\nrm is more permanent than dragging something to the Trash/Recycle Bin. By default, it doesn’t send files to a “trash”, it permanently deletes them. Use with caution!\n\n\n\nPackage management\nThe next concept to tackle on the journey to becoming an AI powered Product Manager is package management. This is a tool your computer uses to install, update, and remove software through the command line. Instead of hunting down installers on websites and clicking through “Next, Next, Finish,” a package manager lets you type a single command to get the tool you need. This matters because it saves time, keeps your environment consistent, and makes it easy to update everything at once which is a helpful when building digital products that depend on multiple tools and libraries. Learning to use a package manager puts you in control of your setup, reduces errors, and helps you work like a professional.\nOn Mac, Homebrew is the standard package manager and must be installed.\nFor Windows, Winget comes pre-installed.\nRun the following commands to install and/or check the version of your package manager.\n\n# Mac\n\n# Install Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Confirm installation by checking which version\nbrew --version\n\n\n# Windows\n\n# winget should be preinstalled on windows\nwinget --version\n\nWinget comes pre-installed on Windows 10 (version 1709+) and Windows 11 so there is generally no need to install it.\n\n\n\nVS Code\nNext we’ll get set up with Visual Studio Code (VS Code), a free, open-source code editor developed by Microsoft that has become one of the most popular development environments among programmers worldwide. Launched in 2015, VS Code combines the simplicity of a lightweight text editor with powerful IDE-like features including intelligent code completion, debugging capabilities, built-in version control integration, and an extensive marketplace of extensions that can add support for virtually any programming language or development workflow. Its cross-platform availability (Windows, macOS), fast performance, and highly customizable interface have made it a favorite among developers working on everything from web applications to machine learning projects. We will build applications within VS code throughout the semester.\nLet’s install it via the package manager.\n\n# Install VS Code using Homebrew\nbrew install --cask visual-studio-code\n\nNote: The –cask flag tells Homebrew to install a GUI application rather than a command-line tool.\n\n# Install VS Code using Windows Package Manager\nwinget install Microsoft.VisualStudioCode\n\n\n\nClaude Code\nClaude Code is a command-line tool that enables developers to delegate coding tasks directly to Claude AI from their terminal, creating an agentic coding experience where Claude can autonomously handle complex development workflows. Unlike traditional AI coding assistants that provide suggestions, Claude Code allows Claude to take full ownership of coding tasks, from analyzing requirements and planning implementation to writing, testing, and iterating on code across multiple files and directories. The tool is designed to integrate seamlessly into existing development workflows, allowing developers to describe what they want to build in natural language and have Claude execute the entire development process, including debugging, refactoring, and implementing best practices, while maintaining transparency through detailed logging and the ability for developers to review and approve changes at each step.\nOf course this won’t build you a perfect, complicated application all by itself but it figuratively gives you a rocket pack, crane, and power tools while building a house.\n\n\n\nCode your first app\nOpen VS Code and create a new directory where you will save your application files.\n\n\n\n\n\n\nFile and folder naming principles\n\n\n\n\n\nAI will often help create file names for you, but when manually creating files or folders, the following guidelines are highly recommended:\nGeneral Naming Principles\n\nUse lowercase → avoids cross-platform issues.\nHyphens (-) instead of spaces or underscores.\nExample: data-cleaning instead of Data_Cleaning or data cleaning.\nBe descriptive but concise.\nExample: customer-surveys-2025.csv is better than cs25.csv.\nAvoid special characters → stick to letters, numbers, and hyphens.\nStay consistent with tense and plurality → e.g., always plural for folders (scripts/, images/).\n\nFolders\nThink of folders as categories of content. Common conventions: - src/ → source code - data/ → raw and/or processed datasets - docs/ → documentation - tests/ → unit/integration tests - notebooks/ → Jupyter or research notebooks - scripts/ → automation scripts - configs/ → configuration files (YAML, JSON, etc.) - assets/ → images, icons, other media\nFiles\nFiles should indicate what they contain or do, not just generic names.\n\nCode files:\ntrain-model.py, evaluate-model.py, preprocess-data.py\nConfiguration files:\nmodel-config.yaml, db-settings.json\nNotebooks (keep order with numbers or dates):\n01-data-exploration.ipynb, 02-feature-engineering.ipynb\nDocumentation:\nREADME.md (always in the root folder), CONTRIBUTING.md, CHANGELOG.md\n\n\n\n\nUsing the command line, make a new folder to contain your project files\n\n# Make use lower\nmkdir my-project\n# Confirm the new directory exists\nls\n# Navigate to the new directory\ncd my-project\n\nStart up Claude Code via the terminal within VS Code. You must first sign up for a Pro account before starting Claude Code.\n\n# Start-up Claude Code\nclaude\n\nAfter starting Claude, turn on Explanatory Mode within Claude which will provide “educational ‘insights’ in between helping you complete software engineering tasks and will help you understand implementation choices and codebase patterns.”\n\n# change the mode of Claude Code so that it explains more about what it's doing\n/output-style explanatory\n\nNotice that changing the output style created a .claude file.\nA .claude file is a configuration file used by Claude Code. These files help define project-specific settings and instructions for how Claude should approach coding tasks in your project.\n.claude files typically contain:\n\nProject context and instructions - Information about your project’s structure, coding standards, and specific requirements\nFile patterns and exclusions - Rules about which files Claude should or shouldn’t modify\nCustom prompts and guidelines - Specific instructions for how you want Claude to approach coding tasks in this particular project\n\nThese files allow you to give Claude persistent context about your project so you don’t have to re-explain your codebase structure, conventions, or preferences every time you use Claude Code. They essentially act as a “memory” for Claude about how to work effectively within your specific project.\nNow, copy paste the following prompt into the active Claude Code terminal session in order to build our first app with Claude Code.\n\nBuild me a simple todo list app using streamlit. Use a json file as the database.\n\n\n\n\n\n\n\nWhat is streamlit?\n\n\n\n\n\nStreamlit is an open-source Python framework for quickly building interactive, data-driven web apps without needing to know front-end development (like HTML, CSS, or JavaScript).\nKey Features Include:\n\nSimplicity: You can turn a Python script into a shareable web app with just a few lines of code.\nWidgets: Built-in components (sliders, dropdowns, checkboxes, file uploaders, etc.) make it easy to collect user input.\nData Visualization Integration: Works seamlessly with libraries like Pandas, NumPy, Matplotlib, Plotly, and Altair.\nDeployment: Apps can be hosted on Streamlit Community Cloud or deployed on your own servers.\n\n\n\n\n\n\n\n\n\n\nHow many lines of code does a production grade business application typically require?\n\n\n\n\n\nA production-grade business application for internal use typically ranges from 10,000 to 500,000+ lines of code, depending on several key factors: Small to Medium Internal Apps (10K-50K lines)\nSimple CRUD applications with basic workflows Departmental tools with limited integrations Small team usage (10-100 users)\nMedium Business Applications (50K-200K lines)\nMulti-module systems with complex business logic Integration with several external systems Company-wide usage (100-1000+ users) Advanced reporting and analytics features\nLarge Enterprise Applications (200K-1M+ lines)\nComprehensive business management systems Extensive integrations and APIs Multi-tenant or highly scalable architectures Complex compliance and security requirements\nFactors that significantly impact size:\n\nComplexity of business logic - Financial calculations, approval workflows, etc.\nNumber of integrations - APIs, databases, third-party services\nUser interface sophistication - Simple forms vs. rich dashboards Technology stack - Some frameworks require more boilerplate code\nCode quality practices - Well-structured code with proper separation of concerns Testing coverage - Test code can represent 30-50% of total codebase\n\nModern considerations: Many internal applications today leverage low-code platforms, cloud services, and existing frameworks, which can reduce custom code requirements significantly. A modern internal app might accomplish what previously took 100K lines with just 20-30K lines by using pre-built components and services.\n\n\n\n\n\nCode your second app\nSpend the next 15 minutes coming up with another application. For simplicity for now, continue using streamlit (i.e. include in your prompt that the application should be built using streamlit).",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>AI Product Management</span>"
    ]
  },
  {
    "objectID": "01-pm-ai-era.html#student-demos",
    "href": "01-pm-ai-era.html#student-demos",
    "title": "AI Product Management",
    "section": "Student Demos",
    "text": "Student Demos\nLet’s see some of the apps that you built.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>AI Product Management</span>"
    ]
  },
  {
    "objectID": "02-llms-prompt-engineering.html",
    "href": "02-llms-prompt-engineering.html",
    "title": "LLMs & Prompting",
    "section": "",
    "text": "AI and Machine Learning\nTo get the most out of AI and in particular if you plan to build AI powered products (which is different than simply building a product with the help of AI), you need to understand how this technology works, at least at a high level. Artificial Intelligence (AI) is the broad idea of creating computer systems that can perform tasks we normally associate with human intelligence, like understanding language, recognizing patterns, making decisions, and generating creative content.\nMachine Learning (ML) is a subset of AI that focuses on teaching computers to learn from data instead of following hard-coded instructions. In ML, we give the computer many examples (data) and let it find the patterns on its own. The more and better-quality data it sees, the better it gets at making predictions or generating useful outputs.\nWithin machine learning, deep learning uses layers of artificial “neurons”, called a neural network, to handle extremely complex patterns this is the technology behind most modern breakthroughs, including Large Language Models (LLMs) like ChatGPT.\nEven if you won’t be building AI models, understanding the basics concepts of how they are developed will help you ask the right questions, spot opportunities for AI in products, and work effectively with technical teams.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>LLMs & Prompting</span>"
    ]
  },
  {
    "objectID": "02-llms-prompt-engineering.html#ai-and-machine-learning",
    "href": "02-llms-prompt-engineering.html#ai-and-machine-learning",
    "title": "LLMs & Prompting",
    "section": "",
    "text": "Image source: Build a Large Language Model (From Scratch) by Sebastian Raschka\n\n\n\nSupervised Learning\nThe branch of machine learning that powers today’s Generative AI breakthroughs is supervised learning. The term “supervised” refers to the fact that the mathematical model is guided by correct answers from a ground-truth dataset (actual data from the real world), allowing it to learn the mapping from inputs to outputs. These correct answers are often referred to as the labels in a labeled data set. An example is training a model to guess the next word in a sentence by giving it lots of past examples of actual sentences.\nFor instance, imagine we train a model on sentences like:\n\nThe cat sat on the mat.\nShe went to the store.\nI like to eat pizza.\n\nIn each case, the words before the bolded one can be considered the input, and the bolded final word is the label (correct answer or ground-truth). After using many examples to train a model, we can apply the model to new sentences to infer the best next word given any text input.\nIn short: supervised learning is learning patterns from labeled examples so you can make accurate predictions on new, unseen data.\nThe simplest form of supervised learning is simple linear regression, where the goal is to predict a straight line (linear) relationship between an output variable one or more input variables.\nA simple linear regression model takes a single input variable \\(x\\) and predicts the value of a corresponding output variable \\(y\\). For example, the input variable might represent a house’s square footage, and the output variable could represent the value of the home.\nWe can write down the relationship between square footage and value in the form of a mathematical equation (also called a mathematical function or a model):\n\\[\n\\hat{y} = w_0 + w_1 x\n\\]\nWhere \\(\\hat{y}\\) (pronounced y-hat)represents the predicted home value and \\(x\\) represents the square footage.\nIn machine learning jargon \\(w_0\\) and \\(w_1\\) are called the parameters or weights of the model (hence the use of \\(w\\) in the notation) and describe the nature of the relationship between \\(x\\) and \\(\\hat{y}\\). \\(w_0\\) and \\(w_1\\) are the numbers that the computer will learn (i.e. derive) based on what is observed in real life which will be represented in a training dataset that consists of many input–output pairs.\nThe straight line in the image below helps you visualize the estimated linear relationship that can be learned between an output and an input such as square-footage. The dotted lines connecting the individual data points to the fitted red line show how far off the model predictions are from ground truth. The process of training a model tries out different values for the paramaters as it searches for the ones that will minimize the prediction errors. The way you compute the prediction error is called the “loss function” (in this case, the loss function could be defined as: \\(|predicted - actual|\\)). The name for this iterative algorithm that looks for the best possible weights is called gradient descent.\n\n\n\n\n\n\nWhat is gradient descent?\n\n\n\n\n\nGradient descent is a family of machine learning algorithms that update a model’s parameters (weights) so that they can make better predictions over time. The word “gradient” refers to multivariate version of a derivative (rate of change) from calculus. The rate of change in this context is how quickly the prediction error changes when you change model parameters.\nAn analogy will help with the intuition. Imagine the height of a hillside represents the sum of all the prediction errors. The point where you are standing on the hillside represents the current model parameters (weights). The goal is to get down the hill onto the valley floor (which implies reducing the prediction error) as fast as possible by taking the steepest path down. Each step down corresponds to a testing out a different set of model parameters to see how accurate the model predictions become. The gradient (i.e. the rate of change in the prediction error as the model parameters are adjusted) is computed and tells you which direction is steepest. You take another step (i.e. smartly choose new values for the parameters) and keep repeating this process until you are confident you’ve found the model paramaters that minimize the prediction error.\n\n\n\n\n\n\n\n\nWhile linear regression is useful for modeling straight-line relationships between inputs and outputs, we need something much more flexible to capture the complexity of human language. Neural networks provide such a tool. First inspired in the 1940s as mathematical models of the brain, they languished for decades but are now realizing their full potential, with large datasets and powerful hardware enabling complex networks to excel in vision and language applications.\n\n\nNeural Networks\nLike linear regression, a neural network is fundamentally a mathematical function that defines a relationship between inputs and outputs. A deep understanding of neural networks is beyond the scope of this course, but we will at least introduce a visual and show the mathematical function to give you some sense for what’s going on under the hood.\nA simple neural network can be written as:\n\\[\n\\hat{y} = f\\!\\big(W^{(2)}\\, g(W^{(1)} x + b^{(1)}) + b^{(2)}\\big)\n\\] Where:\n\n\\(W\\)s are matrices containing the model weights (parameters)\n\\(x\\) is now a vector of inputs (1 or many inputs),\n\\(b\\)s are analogous to intercept terms (called “bias”)\n\\(f(\\cdot)\\) and \\(g(\\cdot)\\) are referred to as activation functions\n\nAs you can see in the above equation, a neural network is a composite a several functions. For larger neuron networks many functions are nested.\nNeural networks are often described in visual terms like in the image below:\n\n\n\n\n\nA neural network is organized into layers that gradually transform inputs into a prediction. The first layer, called the input layer, represents the features we provide to the model. In the home value example, the inputs might be the square footage of the home and the number of bedrooms. A bias input fixed at 1 is also included, giving the network more flexibility to shift its predictions up or down regardless of the raw feature values. Each circle in the diagram is called a neuron or unit, and the lines connecting them are referred to as edges. Each edge represents a weight or bias parameter that the model learns during training. These inputs are passed into the hidden layer, where each neuron acts like a mini regression equation of its own. Each neuron computes a weighted sum of the inputs, adds its bias, and then applies a function we call \\(g\\). This is known as an activation function, and its role is to bend straight-line relationships into curves so the network can capture more complex patterns. For instance, in our housing example, \\(g\\) might allow the model to learn that the first 500 square feet add a lot of value, while additional square footage adds less. Without this step, the network would behave just like plain linear regression.\nFinally, the hidden layer feeds into the output layer. Here, the activations are combined again using new weights and a bias, and then passed through another function, usually called \\(f\\). You can think of \\(f\\) as the final shaping step that ensures the prediction is in the right form for the task. For predicting home prices, \\(f\\) might simply output a dollar amount. For classification problems, \\(f\\) might produce a probability between 0 and 1.\nWhereas simple linear regression has just two parameters to estimate (a slope and an intercept), the small neural network in the diagram already has 13 parameters. The number of parameters grows quickly as networks get larger, which is what gives them the ability to represent more complex relationships. Modern neural networks that power chatbots such as ChatGPT are astonishingly large by comparison, containing hundreds of billions of parameters. GPT-3, for example, was trained with 175 billion parameters, and the newest generations are even larger. This massive scale enables them to capture subtle patterns in language, context, and reasoning, allowing them to generate coherent, human-like responses.\nOf course, this complexity comes with trade-offs: training such large models requires enormous amounts of data, specialized hardware such as GPUs and TPUs, and advanced optimization techniques. But the underlying principle is the same as in the small housing example above where each parameter represents a weight or bias that adjusts how inputs are transformed into outputs. The difference is simply one of scale.\nYou won’t need to fully understand or know the math behind neural networks for this course, but you should at least see it once which many people never do. The neural network shown in the visualization above is written mathematically in the steps that follow:\nAll of the weights associated with the edges are combined into a weight matrix and bias vector. The weight associated with the transition from the input layer the hidden layer is shown first followed by the weights and bias that transform the hidden layer into the final output.\n\\[\nW^{(1)} \\in \\mathbb{R}^{3 \\times 2} =\n\\begin{bmatrix}\nw^{(1)}_{11} & w^{(1)}_{12} \\\\\nw^{(1)}_{21} & w^{(1)}_{22} \\\\\nw^{(1)}_{31} & w^{(1)}_{32}\n\\end{bmatrix},\n\\quad\nb^{(1)} \\in \\mathbb{R}^{3} \\;=\\;\n\\begin{bmatrix}\nb^{(1)}_{1} \\\\\nb^{(1)}_{2} \\\\\nb^{(1)}_{3}\n\\end{bmatrix}\n\\]\n\\[\nW^{(2)} \\in \\mathbb{R}^{1 \\times 3} =\n\\begin{bmatrix}\nw^{(2)}_{11} & w^{(2)}_{12} & w^{(2)}_{13}\n\\end{bmatrix},\n\\quad\nb^{(2)} \\in \\mathbb{R} \\;=\\;\n\\begin{bmatrix}\nb^{(2)}_{1}\n\\end{bmatrix}\n\\] These can be plugged into the matrix equation that we first showed.\n\\[\n\\hat{y} \\;=\\; f\\!\\Big(W^{(2)}\\, g\\!\\big(W^{(1)} x + b^{(1)}\\big) + b^{(2)}\\Big)\n\\] After doing the matrix computations, the formula would expand into this long set of additions and multiplications.\n\\[\n\\hat{y}\n=\nf\\!\\Big(\nw^{(2)}_{11}\\, g\\!\\big(w^{(1)}_{11} x_1 + w^{(1)}_{12} x_2 + b^{(1)}_1\\big)\n+\nw^{(2)}_{12}\\, g\\!\\big(w^{(1)}_{21} x_1 + w^{(1)}_{22} x_2 + b^{(1)}_2\\big)\n+\nw^{(2)}_{13}\\, g\\!\\big(w^{(1)}_{31} x_1 + w^{(1)}_{32} x_2 + b^{(1)}_3\\big)\n+\nb^{(2)}_{1}\n\\Big)\n\\] Common choices of function for \\(f\\) and \\(g\\) are shown below:\n\\[\nf(z) = \\sigma(z) = \\frac{1}{1 + e^{-z}}\n\\]\n\\[\n\\quad\ng(z) = \\text{ReLU (Rectified Linear Unit)} = \\max(0, z)\n\\] Modern AI models take text and break it into smaller pieces called tokens. A token might be a whole word, part of a word, or even a single character. Each token is then converted into numbers through a process called embedding, which represents it as a vector of numbers that captures aspects of its meaning and how it relates to other tokens.\nEmbeddings are a way to turn different kinds of information like text, audio, or video—into numbers so a computer can work with them.\nAn embedding model is itself a deep neural network that takes raw input (words, sounds, images, etc.) and converts it into a list of numbers that captures the meaning or important features of the input (i.e. a vector). Two inputs with similar meanings will have vectors that are close to each other, even if the exact words, sounds, or images are different.\nEmbeddings are like coordinates on a map of word meanings. They let computers compare, search, and work with language in a numerical and mathematical way.\n\n\n\nImage source: Build a Large Language Model (From Scratch) by Sebastian Raschka\n\n\n\n\n\nImage source: Build a Large Language Model (From Scratch) by Sebastian Raschka\n\n\nThe model typically takes a sequence of token embeddings, for example, a batch representing 10 or so words, as input and is trained to predict the next word in the sequence. During training, it learns from vast collections of text such as books, articles, blogs, and other digital sources, which serve as the ground truth.\nOnce the text has been converted into numbers, the neural network processes these vectors layer by layer, using weights, biases, and activation functions to detect patterns and relationships. With each layer, the model refines its understanding of the context, and at the end of the process, it produces a probability distribution over possible next words and selects the most likely one.\n\n\n\nImage by Sebastian Raschka\n\n\n\n\n\nImage by Sebastian Raschka\n\n\nImage source: Build a Large Language Model (From Scratch) by Sebastian Raschka\n\n\n\n\n\nTo summarize our discussion, modern AI models are ultimately created from 4 foundational ingredients:\n\nA mathematical model: This defines the form of the mathematical relationship used to relate inputs to outputs, for example, a straight line (linear) or a more flexible structure like a neural network (non-linear).\nTraining data: A collection of real-world examples that pair inputs with their corresponding outputs. The quality and relevance of this data are crucial to how well the model can learn and make accurate predictions. In the case of LLMs, the training data is a gigantic corpus of text (i.e. books, blogs, etc.)\nA “loss” function: A mathematical expression that measures how far off the model’s predictions are from the correct answers found in the train data. The loss function provides feedback on prediction accuracy and helps the model improve over time.\nA training algorithm: A step-by-step procedure that combines the first three ingredients in a way that minimizes the prediction errors produced by the model. This is where the so-called learning takes place. Modern AI models are trained using algorithms based on gradient descent.\n\n\n\nLarge Language Models and Generative AI\nLarge Language Models (LLMs) are built using massive neural networks and are the core technology behind much of today’s Generative AI. They are built in two main stages: pretraining and fine-tuning\n\n1. Gathering and Processing Text Data\nThe process begins by collecting an enormous body of text from a variety of sources, including internet articles, books, Wikipedia, and research papers. This raw text can contain trillions of words. Before a model can use it, the text is converted into numbers through a process called tokenization. Each word or piece of a word is represented as a vector (a list of numbers) so the computer can process it mathematically.\n\n\n\nImage source: Build a Large Language Model (From Scratch) by Sebastian Raschka\n\n\n\n\n2. Pretraining the Model\nUsing this massive numerical dataset, the model is trained to perform one fundamental task: predicting the next word in a sequence. By doing this billions of times, it learns grammar, facts about the world, reasoning patterns, and relationships between concepts. After pretraining, the LLM becomes a foundation model with basic capabilities such as:\n\nText completion – finishing a sentence or paragraph.\nFew-shot learning – adapting to new tasks with just a few examples in the prompt.\n\n\n\n3. Fine-Tuning for Specific Tasks\nPretraining gives the model broad language skills, but it’s still general-purpose. Fine-tuning makes it specialized. In this stage, the pretrained model is trained again on a labeled dataset—data where each input has a known, correct output. This allows the LLM to excel at targeted applications such as:\n\nClassification – sorting emails as spam or not spam.\nSummarization – condensing long documents into key points.\nTranslation – converting text between languages.\nConversational assistance – answering questions and performing tasks as a chatbot or virtual assistant.\n\n\n\n4. The Big Picture\n\nPretraining = learning the general rules of language and knowledge.\nFine-tuning = specializing for specific, high-performance applications.\n\nTogether, these steps create powerful AI systems capable of generating text, answering questions, and performing a wide variety of language-based tasks.\n\n\n\nImage source: Build a Large Language Model (From Scratch) by Sebastian Raschka\n\n\n\n\n\nImage source: Build a Large Language Model (From Scratch) by Sebastian Raschka\n\n\n\n\n\nGPT Architecture\nDigging into the full details of the GPT architecture is beyond the scope of this course. However, it’s useful to recognize diagrams like this, which present the high-level structure of the model. At the bottom, tokenized text (converted into numerical tokens) passes through an embedding layer that maps each token to a numerical vector. A positional embedding layer adds information about word order.\nThe heart of GPT is the transformer block (shaded in blue), repeated many times (e.g., 12 layers for GPT-2 Small, 48 for GPT-2 XL). Each block contains:\n\nMasked multi-head attention – allows the model to focus on relevant words in the input while preventing it from “seeing” future words during training.\nFeed-forward layers – process and transform the attention outputs.\nLayer normalization and dropout – improve stability and reduce overfitting.\n\nEach layer in the GPT architecture is part of a deep neural network and performs a sequence of mathematical operations—primarily matrix multiplications and additions—that transform the input vectors into increasingly abstract representations of the text. During training, the model’s parameters (weights) are adjusted using gradient descent, an optimization process that reduces prediction errors by calculating how much each weight should change based on the difference between the model’s output and the correct answer.\nAfter going through all the layers, the model tidies up its final internal calculations and then turns them into a list of possible next words, each with a score for how likely it is to come next. The word with the highest score is usually chosen as the model’s prediction.\n\n\n\nImage source: Build a Large Language Model (From Scratch) by Sebastian Raschka",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>LLMs & Prompting</span>"
    ]
  },
  {
    "objectID": "02-llms-prompt-engineering.html#prompting",
    "href": "02-llms-prompt-engineering.html#prompting",
    "title": "LLMs & Prompting",
    "section": "Prompting",
    "text": "Prompting\nNow that we understand a bit about what powers modern AI, let’s get practical and discuss prompting techinques to get the most out of it.\nPrompts come in many shapes, depending on your goals, the complexity of the task, and how much control you need over the AI’s output. Understanding the anatomy of different prompt structures helps you choose the right one for the job.\n\n\n\n\n\n\n\n\n\nPrompt Type\nWhat it is\nExample\nBest for\n\n\n\n\nSingle-Turn Prompt\nA one-off instruction or question sent to the model.\nSummarize this article in three bullet points.\nQuick tasks where context isn’t needed beyond the immediate request.\n\n\nRole-Based Prompt\nSets a clear role or persona for the AI to adopt.\nYou are an experienced product manager. Draft a launch plan for a new mobile app.\nWhen tone, perspective, or expertise level matters.\n\n\nContext + Instruction Prompt\nCombines background information with a direct request.\nBackground: Our company sells eco-friendly cleaning products online. Task: Write a short ad targeting parents concerned about chemical safety.\nWhen the model needs background to produce relevant results.\n\n\nFew-Shot Prompt\nIncludes examples of desired input-output pairs to guide the model’s style or format.\nQ: What is the capital of France? A: ParisQ: What is the capital of Germany? A: BerlinQ: What is the capital of Italy? A:\nTraining the model in your preferred style or pattern without fine-tuning.\n\n\nMulti-Turn Conversation\nA back-and-forth exchange where previous messages build context.\nUser: Give me a list of U.S. national parks in the West.AI: [List]User: Now sort them by size.\nComplex tasks where you refine or expand the request over time.\n\n\nDynamic, Variable-Injected Prompt\nA template where parts of the prompt are filled in with live or changing data.\nWrite a {tone} introduction to {topic} for someone named {name}.\nAutomation, personalization, and programmatic API workflows.\n\n\n\nBy mixing and matching these structures, you can create prompts that are concise, rich in context, and tailored for automation and enabling far more consistent and useful AI outputs.\n\nProgrammatic Prompting\nAI’s impact grows dramatically when you automate prompts and dynamically inject fresh data into them.\nThe python code chunk below illustrates how to do this.\n\nimport os\nimport time\nimport pandas as pd\nfrom openai import OpenAI\n\n# --- Config ---\nINPUT_CSV = \"input.csv\"\nOUTPUT_CSV = \"output.csv\"\nMODEL = \"gpt-4o-mini\"\nSYSTEM_PROMPT = \"You are a helpful assistant.\"\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\", \"YOUR_OPENAI_API_KEY\")  # or set env var\n\n# --- Client ---\nclient = OpenAI(api_key=API_KEY)\n\n# --- Load data ---\ndf = pd.read_csv(INPUT_CSV)\n\n# Ensure expected columns exist\nfor col in [\"name\", \"topic\", \"tone\"]:\n    if col not in df.columns:\n        raise ValueError(f\"Missing required column: {col}\")\n\ndef call_api(row, retries=3, backoff=2.0):\n    \"\"\"Call OpenAI once per row with simple retry/backoff.\"\"\"\n    prompt = f\"Write a {row['tone']} introduction to {row['topic']} for someone named {row['name']}.\"\n    for attempt in range(retries):\n        try:\n            resp = client.chat.completions.create(\n                model=MODEL,\n                messages=[\n                    {\"role\": \"system\", \"content\": SYSTEM_PROMPT},\n                    {\"role\": \"user\", \"content\": prompt},\n                ],\n                temperature=0.7,\n            )\n            # Newer client returns attributes, not dicts:\n            return resp.choices[0].message.content.strip()\n        except Exception as e:\n            if attempt == retries - 1:\n                return f\"Error: {e}\"\n            time.sleep(backoff ** attempt)\n\n# --- Run generation ---\ndf[\"response\"] = df.apply(call_api, axis=1)\n\n# --- Save results ---\ndf.to_csv(OUTPUT_CSV, index=False)\nprint(f\"Done. Wrote {len(df)} rows to {OUTPUT_CSV}\")\n\nThis script reads a CSV, sends each row’s data to the OpenAI API, and saves the responses to a new CSV.\nFlow:\ninput.csv → Pandas DataFrame → AI prompt → OpenAI API → response → output.csv\nA more detailed summary of what the code does is below:\n\nImport libraries – pandas for CSV handling, openai for API calls, time for retries.\nConfig settings – file paths, model name, system prompt, API key.\nCreate client – client = OpenAI(api_key=API_KEY) to connect to OpenAI.\nLoad CSV – df = pd.read_csv(INPUT_CSV) stores the spreadsheet in a DataFrame.\nCheck columns – ensure name, topic, and tone exist.\nDefine call_api() – builds a dynamic prompt, sends it to the API, retries if needed.\nApply function – df[\"response\"] = df.apply(call_api, axis=1) runs the prompt for each row.\nSave output – df.to_csv(OUTPUT_CSV, index=False) writes results to a new file.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>LLMs & Prompting</span>"
    ]
  },
  {
    "objectID": "03-product-innovation.html",
    "href": "03-product-innovation.html",
    "title": "Product Innovation",
    "section": "",
    "text": "The Lean Product Process\nThe Lean Product Process is a repeatable framework for systematically developing products that customers love developed by Dan Olsen.\nIt moves from deeply understanding customer needs (problem space) to iterating on solutions (solution space), always validating with customer feedback.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Product Innovation</span>"
    ]
  },
  {
    "objectID": "03-product-innovation.html#target-customer",
    "href": "03-product-innovation.html#target-customer",
    "title": "Product Innovation",
    "section": "Target Customer",
    "text": "Target Customer\nIdentify the specific segment of people who will benefit most from your product.\nNot “everyone who might use it” — your primary audience you will optimize for first.\n\nUser Personas\n\nCreate 2–3 detailed fictional profiles representing your core customers.\nInclude:\n\nDemographics (age, job role, location)\nBehaviors (habits, buying channels, product usage patterns)\nGoals and motivations\nPain points and frustrations\n\nUse direct quotes from customer interviews when possible.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Product Innovation</span>"
    ]
  },
  {
    "objectID": "03-product-innovation.html#underserved-needs",
    "href": "03-product-innovation.html#underserved-needs",
    "title": "Product Innovation",
    "section": "Underserved Needs",
    "text": "Underserved Needs\nDetermine what matters most to your target customers and where current solutions fail them.\n\nImportance vs. Satisfaction\n\nPlot needs on a 2x2:\nImportance (how critical is it to the customer?)\nSatisfaction (how well do current solutions address it?)\nHigh importance + low satisfaction = prime opportunity.\n\n\n\n\nImage source: The Lean Product Playbook by Dan Olsen\n\n\n\n\nJobs to Be Done\n\nFrame needs as jobs customers are trying to accomplish.\nFormat:\n\nWhen I’m [situation], I want to [motivation], so I can [desired outcome].\n\nCapture all:\n\nEmotional jobs (how they want to feel)\nSocial jobs (how they want to be perceived)\nFunctional jobs (what they want to get done)\n\n\n\n\n\nImage source: Jeff Dyer, Innovators DNA",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Product Innovation</span>"
    ]
  },
  {
    "objectID": "03-product-innovation.html#value-proposition",
    "href": "03-product-innovation.html#value-proposition",
    "title": "Product Innovation",
    "section": "Value Proposition",
    "text": "Value Proposition\nCraft a clear statement that answers:\n\nWho the product is for\n\nWhat it does for them\n\nWhy it’s better or different than alternatives\n\nKeep it short (1–2 sentences) and customer-oriented.\n\n\n\nImage source: Strategyzer\n\n\n\nCustomer Journey Map\nA customer journey map is a tool that shows the step-by-step experience a customer has with a product or experience.\nIt can be useful because it helps you:\n\nSee the experience through the customer’s eyes.\nSpot pain points and improvement opportunities.\nAlign your team around what really matters to customers.\n\nIt’s a tool for designing a smoother, more valuable customer experience.\n\n\n\nImage source: Heart of the Customer\n\n\n\n\nMoral Foundations Analysis",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Product Innovation</span>"
    ]
  },
  {
    "objectID": "03-product-innovation.html#feature-set",
    "href": "03-product-innovation.html#feature-set",
    "title": "Product Innovation",
    "section": "Feature Set",
    "text": "Feature Set\nList the features that directly address underserved needs.\n\nRank features by customer value and feasibility.\nAvoid “feature creep” — every feature must trace back to a validated need.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Product Innovation</span>"
    ]
  },
  {
    "objectID": "03-product-innovation.html#user-experience",
    "href": "03-product-innovation.html#user-experience",
    "title": "Product Innovation",
    "section": "User Experience",
    "text": "User Experience\nTranslate features into an intuitive, delightful, and friction-free customer journey.\n\nPrinciples of UX Design\n\nClarity – Every screen communicates its purpose instantly.\nConsistency – Patterns, language, and visual design align across the product.\nFeedback – Users get immediate, understandable responses to actions.\nEfficiency – Reduce cognitive load and clicks for key tasks.\nEmpathy – Design flows from the user’s point of view, not the internal org chart.\n\nDan Olsen’s iceberg reminds us that great UX starts deep below the surface.\n\nConceptual Design → Drives Clarity: a solid mental model ensures screens make sense instantly.\nInformation Architecture → Enables Efficiency: well-organized content reduces cognitive load.\nInteraction Design → Supports Consistency and Feedback: familiar patterns and responsive flows guide users.\nVisual Design → Reinforces Empathy: aesthetics reflect users’ needs and context.\n\nA polished UI alone can’t deliver on these principles, they must be built into every layer of the iceberg.\n\n\n\nImage source: The Lean Product Playbook by Dan Olsen",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Product Innovation</span>"
    ]
  },
  {
    "objectID": "03-product-innovation.html#pitch-deck",
    "href": "03-product-innovation.html#pitch-deck",
    "title": "Product Innovation",
    "section": "Pitch Deck",
    "text": "Pitch Deck\nWhat do you have to believe for this to be a good idea?\nBeing non-consensus and right",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Product Innovation</span>"
    ]
  },
  {
    "objectID": "04-value-prop-design.html",
    "href": "04-value-prop-design.html",
    "title": "Prototying and MVP",
    "section": "",
    "text": "Design and Protyping Tools",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Prototying and MVP</span>"
    ]
  },
  {
    "objectID": "04-value-prop-design.html#design-and-protyping-tools",
    "href": "04-value-prop-design.html#design-and-protyping-tools",
    "title": "Prototying and MVP",
    "section": "",
    "text": "Figma\nFigma is a collaborative design tool used to create, refine, and share user interface (UI) and user experience (UX) designs. It enables teams to work together in real time, using shared design files, reusable components, interactive prototypes, and built-in commenting to streamline the process from concept to final design.\nFor product managers, Figma is a commonly used tool for aligning teams around a shared vision. It allows PMs to visualize product ideas, give feedback directly on designs, collaborate with designers and developers, and share clickable prototypes for testing. This helps speed up decision-making, improve communication, and ensure the final product matches the intended user experience.\nNew AI design and prototyping tools are rapidly changing where Figma sits in the product tech stack. Figma itself is rapidly evolving into an AI first company with the launch of their Figma Make product.\n\n\n\nReplit, Bolt, V0, Lovable\nA number of AI tools—such as Replit, Bolt, V0, and Lovable—are now making it possible to generate high-fidelity mockups and even functional prototypes directly from text prompts. In some cases, this can bypass the need for sophisticated clickable mock-ups in Figma, since these tools merge design and development into a single step. For example, V0 can turn descriptions into production-ready React components, Bolt can generate full-stack web apps from a prompt, Lovable can design and deploy complete products, and Replit enables collaborative, AI-assisted coding. These platforms are shifting the product workflow, reducing the time from concept to working product and changing how and when Figma fits into the process.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Prototying and MVP</span>"
    ]
  },
  {
    "objectID": "04-value-prop-design.html#customer-feedback-and-rapid-iteration",
    "href": "04-value-prop-design.html#customer-feedback-and-rapid-iteration",
    "title": "Prototying and MVP",
    "section": "Customer Feedback and Rapid Iteration",
    "text": "Customer Feedback and Rapid Iteration\nOnce you have a prototype built in Figma or generated with an AI tool like Bolt, V0, Lovable, or Replit, the next step is to put it in front of real or representative users as quickly as possible. The goal is to validate whether the product solves the right problem, delivers value, and feels intuitive to use before investing heavily in full-scale development.\nEffective approaches include usability testing, where you watch customers interact with the prototype and note points of confusion or friction, and structured interviews or surveys, where you ask targeted questions about specific features, flows, or visual elements. The key is to focus on observable behavior and specific feedback rather than general opinions.\nOnce feedback is gathered, teams can rapidly update the prototype, often in hours rather than what used to be weeks, making changes to the flow, visuals, or feature set. This fast feedback loop allows product managers to refine the solution, confirm alignment with customer needs, and de-risk development before committing resources. Over multiple iterations, this process builds confidence that the final product will be both usable and valuable.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Prototying and MVP</span>"
    ]
  },
  {
    "objectID": "04-value-prop-design.html#minimum-viable-product",
    "href": "04-value-prop-design.html#minimum-viable-product",
    "title": "Prototying and MVP",
    "section": "Minimum Viable Product",
    "text": "Minimum Viable Product\nA Minimum Viable Product isn’t a stripped-down final product, it’s the smallest version that is functional, reliable, and usable enough to validate your value proposition. The goal is to build just enough to test with real customers, gather feedback, and then iterate\n\n\n\nImage source: The Lean Product Playbook by Dan Olsen",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Prototying and MVP</span>"
    ]
  },
  {
    "objectID": "05-project-management-jira.html",
    "href": "05-project-management-jira.html",
    "title": "Project Management",
    "section": "",
    "text": "Agile\nAgile is a way of managing work that emphasizes flexibility, collaboration, and delivering value quickly. Instead of long, rigid project plans, Agile teams work in short cycles, learn from feedback, and adjust as they go.\nManifesto for Agile Software Development",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Project Management</span>"
    ]
  },
  {
    "objectID": "05-project-management-jira.html#agile",
    "href": "05-project-management-jira.html#agile",
    "title": "Project Management",
    "section": "",
    "text": "Ceremonies\nAgile frameworks often include regular team events (called ceremonies) to keep work organized and communication clear:\n\nSprint Planning – Decide what the team will work on in the next sprint.\nDaily Stand-up – A quick, daily check-in to share progress and obstacles.\nSprint Review – Show completed work to stakeholders and get feedback.\nSprint Retrospective – Reflect on what went well and what could improve.\n\n\n\nScrum and Kanban\n\nScrum – Work is organized into fixed-length sprints (usually 1–4 weeks) with defined roles like Product Owner, Scrum Master, and Development Team.\nKanban – Focuses on continuous flow of work using a visual board, with no fixed sprint cycles, limiting the number of tasks in progress at once.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Project Management</span>"
    ]
  },
  {
    "objectID": "05-project-management-jira.html#user-stories",
    "href": "05-project-management-jira.html#user-stories",
    "title": "Project Management",
    "section": "User Stories",
    "text": "User Stories\nUser stories describe features from the perspective of the person who will use them. A common format is:\n\nAs a [type of user], I want [goal] so that [reason/benefit].\n\nExample:\n- As a customer, I want to reset my password so that I can access my account if I forget it.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Project Management</span>"
    ]
  },
  {
    "objectID": "05-project-management-jira.html#jira-and-github-projects",
    "href": "05-project-management-jira.html#jira-and-github-projects",
    "title": "Project Management",
    "section": "Jira and GitHub Projects",
    "text": "Jira and GitHub Projects\n\nJira – A project management tool widely used for tracking work in Agile teams. It supports Scrum and Kanban boards, backlogs, and reporting.\nGitHub Projects – A flexible, board-based system integrated with GitHub repositories, useful for managing tasks alongside code development.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Project Management</span>"
    ]
  },
  {
    "objectID": "05-project-management-jira.html#product-requirements-documents-prds",
    "href": "05-project-management-jira.html#product-requirements-documents-prds",
    "title": "Project Management",
    "section": "Product Requirements Documents (PRDs)",
    "text": "Product Requirements Documents (PRDs)\nA PRD explains what a product should do, why it’s needed, and how success will be measured. Typical sections include:\n\nOverview – What the product or feature is.\nObjectives – Why it’s being built.\nUser Stories / Use Cases – How users will interact with it.\nFunctional Requirements – Specific capabilities and behaviors.\nNon-Functional Requirements – Performance, security, or usability standards.\nSuccess Metrics – How you’ll know it’s working.\n\nPRDs help ensure everyone including design, engineering, and marketing share the same understanding of what’s being built and why.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Project Management</span>"
    ]
  },
  {
    "objectID": "06-collaboration-git-triad.html",
    "href": "06-collaboration-git-triad.html",
    "title": "GitHub & Collaboration",
    "section": "",
    "text": "Git & GitHub\nAlthough the terms Git and GitHub are often used interchangeably, they are two distinct tools that work together.\nGit is an open-source version control system that individual users install on their local computer. It tracks every change you make to the files in a specified folder (called a repository) and acts like a time machine allowing you to go back to any previous version, see what changed, when it changed, and who made the change. Git is the most widely used version control system in the world, with an estimated 90–95% of professional software development teams using it today.\nGitHub is a cloud-based platform, owned by Microsoft, that allows you to store your Git repositories online, making it easy to collaborate with others over the internet. You can think of GitHub as the Google Drive or Dropbox of your code files, but with additional tools for teamwork and project management that extend the use of Git from individuals to entire teams. Developers use Git on their local machines and push their files and subsequent changes to GitHub when they’re ready to share or back them up online. Product Managers and other collaborators can then review, comment on, and track progress through the GitHub web interface.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>GitHub & Collaboration</span>"
    ]
  },
  {
    "objectID": "06-collaboration-git-triad.html#the-four-sections-of-the-gitgithub-workflow",
    "href": "06-collaboration-git-triad.html#the-four-sections-of-the-gitgithub-workflow",
    "title": "GitHub & Collaboration",
    "section": "The Four Sections of the Git/GitHub Workflow",
    "text": "The Four Sections of the Git/GitHub Workflow\nA typical workflow in get consists of editing files in your working directory, staging them, which just means listing which ones you want to save, saving or committing them and lastly, pushing them to a remote cloud hosted folder for others to use.\n1. Working Directory\nThe Working Directory is the folder on your computer where you’re actively making changes to files such as writing code, editing documents, or creating new files.\nA Working Directory is just a regular folder you’re already familiar with, the kind you see in Windows Explorer or Mac Finder.\n2. Staging Area\nThe Staging Area is a place where you catalogue (or “stage”) the edited files from the Working Directory that you want to include in your next snapshot (version) of your project.\nEach snapshot is called a commit, and the Staging Area lets you choose exactly which edited files will be saved in the next official version of your project.\nEven if you’ve edited, say, 5 files, you may only want to include 3 of those changed files in your next commit. The Staging Area is where you make these choices, it gives you control over what gets saved and when.\nYou may hear the Staging Area referred to as the index because that’s the technical name Git uses internally for this part of the system.\n3. Local Repository\nThe Local Repository is the part of Git on your computer that stores the official history of your project: all the snapshots (commits) you’ve made so far.\nWhen you commit (i.e., Save) changes from the Staging Area, Git saves a permanent version of those changes in your Local Repository. This allows you to go back in time, review past versions, undo mistakes, or see who changed what and why.\nYou can think of the Local Repository as your personal project archive that keeps track of every meaningful step in your project’s development.\nUnlike the Working Directory, the Local Repository is not a folder you typically see in Finder or Windows Explorer, rather, it lives inside a hidden folder named .git. Git uses the hidden .git folder to store all your commits as well as other project related information. It is possible to unhide the .git folder and browse it like a normal folder but many of the files are not human readable since they are designed for Git’s internal use and may look confusing or cryptic to most users.\nEven though the files in the .git folder aren’t meant to be read directly by humans, Git commands allow you to retrieve any saved snapshot of your project and restore files in their original, human-readable form.\nSo the local repository contains everything from your Working Directory that you chose to stage and then commit.\nThink of the .git folder as a vault of your project’s history. You can’t really read the vault contents directly, but Git gives you keys (commands) to retrieve and restore anything you’ve ever committed.\n4. Remote Repository\nThe Remote Repository is a copy of your Local Repository that is stored on the internet using a platform like GitHub.\nIt contains the same kinds of commits and project history as your Local Repository, but it’s shared with others, which makes it perfect for collaborating with teammates, backing up your work, or deploying projects.\nYour Local Repository is your personal copy, just on your computer.\nThe Remote Repository is the shared copy in the cloud that you and your team keep in sync.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>GitHub & Collaboration</span>"
    ]
  },
  {
    "objectID": "06-collaboration-git-triad.html#illustrating-the-workflow",
    "href": "06-collaboration-git-triad.html#illustrating-the-workflow",
    "title": "GitHub & Collaboration",
    "section": "Illustrating the Workflow",
    "text": "Illustrating the Workflow\nThe illustration below helps you visualize the four parts of a Git workflow.\n\nThe most fundamental unit in Git is a repository, often called a repo for short. A repository is a special folder that contains all the files related to your project, along with the metadata Git uses to track the full history of changes.\nThe best way to\nGit and GitHub Operate on a Four-Level Hierarchy\nGit and GitHub organize your project using a four-level hierarchy, each building on the one below:\nLevel 1 – Files\nThese are the individual files in your project, most commonly plain text files containing code (like .py, .html, or .js), but other file types such as images (.png, .jpg) and data files (.csv, .json) are also supported and commonly used.\nLevel 2 – Commits\nA commit is a snapshot of your entire project at a specific point in time. Git stores the exact state of all tracked files when you make a commit. Each commit has a unique identifier called a hash (e.g., f04e112) that lets you reference or return to that version.\nThe word commit can be both a noun (“This commit broke the build”) and a verb (“I’m committing my changes”), meaning to save a snapshot of the current state of your project.\nLevel 3 – Branches\nA branch is a named reference (a pointer) to the latest commit in a line of development.\nHEAD is a special pointer that tracks where you are in the Git repo.\nMost of the time, it points to a branch name (like main or feature-x). In special cases, HEAD can point directly to a commit, putting you in a detached HEAD state.\nA branch is a pointer to the most recent commit in a line of development. Because each commit remembers its parent, this pointer implicitly defines a sequence of commits — the branch’s history.\nA is a label (or pointer) to a single commit — specifically, the tip (latest commit) of a line of development. Git doesn’t store branches as separate sequences of commits. Instead:\nThe branch points to the most recent commit. That commit points to the previous commit. And so on, forming a linked list of history. Developers use branches to work on features or bug fixes in isolation. Most repositories have a default branch called main (previously called master), which typically represents the production-ready version of the code.\nWhen you check out a branch, Git updates your working directory to reflect the latest commit on that branch. You’re not editing that commit itself — instead, you’re preparing to build on top of it. Any changes you make and commit will be saved as a new commit, extending the history of the branch.\nLevel 4 – Repositories\nA repository (or repo) is the top-level container that holds all your project’s files, commit history, branches, and metadata. It’s essentially your entire project, tracked and version-controlled. Repositories can live on your local computer (with Git) or be hosted online (e.g., on GitHub) for sharing and collaboration.\n🔍 What Exactly Is in a Git Repository?\nA repository (or repo) in Git is the full structure that stores:\nCommits: Snapshots of the project’s file state over time Branches: Named pointers to specific commits Tags: Named, static pointers to commits (usually used for releases) Refs: Internally, all pointers (branches, tags, HEAD) are stored as refs Blobs: File contents (each version of each file) Trees: Directory structures (which files go in which folders) HEAD: A special ref pointing to your current working location Configuration: Repo settings like remotes, ignore rules, hooks, etc. So yes: a Git repo is the container for all of this — your entire project, including its full history and structure.\n\nSummary\n\n\n\n\n\n\n\n\nLevel\nConcept\nDescription\n\n\n\n\n1\nFiles\nThe individual contents of your project\n\n\n2\nCommits\nSnapshots of the project at specific points in time\n\n\n3\nBranches\nTimelines of commits used for parallel development\n\n\n4\nRepositories\nThe full project container with history and structure\n\n\n\nThis structure can be visualized as follows:\nAlthough they’re often mentioned together, Git and GitHub are not the same thing.\nRepositories: The Project Container\nA repository (or repo) is your entire project — like a folder that holds all your code, history, and collaboration tools. If you’re writing a novel, the repository is the whole book project, including every chapter, draft, and note you’ve ever made.\nOn your computer, a Git repo is just a regular folder with special tracking enabled. On GitHub, it’s a shared version of that folder hosted in the cloud where others can see, clone, or contribute.\nBranches: Versions You Can Work On Separately\nThe Four Main Conceptual Areas in Git\nHere’s a complete, beginner-friendly framework:\n\nWorking Directory The actual files and folders on your computer that you’re editing. What you see in your file explorer or code editor. Untracked or modified files live here. 👉 You can change files freely here, but Git doesn’t track them until you stage or commit them.\nStaging Area (a.k.a. Index) A preview of what will go into your next commit. You use git add to move changes from the working directory to the staging area. Think of it like a “shopping cart” of changes you’re getting ready to commit. 👉 This gives you fine-grained control over what goes into each commit.\nLocal Repository Where your commits live on your own computer. When you run git commit, you move changes from the staging area into your local repo. This is the full version history that Git manages in the .git directory. 👉 You can make lots of commits locally without pushing anything to the cloud.\nRemote Repository A shared copy of your repository hosted online (e.g., on GitHub). You use git push to send commits from your local repository to the remote. You use git pull or git fetch to bring changes from the remote down to your local repo. 👉 Enables collaboration, backups, and deployment.\n\nThe primary purpose of a branch in Git is to give a human-readable name to a commit, so you don’t have to use the full hash.\nWhy Branches Exist in Git\n\nCommits Are Identified by Hashes Every commit is named by a SHA-1 hash like:\n\nBranches Are Named Pointers A branch (like main, feature-x, or fix-bug-7) is a named reference to a commit. As you commit, the branch name moves forward to the new commit.\nmain → commit A → commit B → commit C refs/heads/main → abc123 → def456 → 9a3e6c2\n🧭 What a Branch Really Is\nA branch is just a label (a file inside .git/refs/heads/) that contains a commit hash. Example:\ncat .git/refs/heads/main Might output:\n9a3e6c2bd8c2fb4f09f7bbfe42f27f3853fccc60 That’s it. A branch is literally a text file with a hash in it.\nAs you commit, the branch “moves forward” automatically\nDetached HEAD mode means that HEAD is pointing directly to a specific commit hash, not to a branch.\nWhat Is Detached HEAD Mode?\nIn normal Git use:\nHEAD → main → commit abc123 In detached HEAD mode:\nHEAD → commit abc123 ← no branch involved This happens when you check out a commit directly:\ngit checkout abc123 Now you’re no longer “on a branch.” You’re just sitting on a specific commit.\n🎯 Why Is This Useful?\nYou might enter detached HEAD mode when:\nYou want to test or explore an old version without changing any branches You want to build something temporary, like a patch or debug run You’re checking out a tag (tags also point to commits) ⚠️ Gotcha: What Happens If You Commit in Detached Mode?\nYou can still make commits, and Git will let you — but:\nThey’ll be “floating” — not attached to any branch If you switch branches afterward, you could lose them unless you create a new branch from that point\nA commit is the fundamental unit in Git. Branches, tags, and HEAD are just labels or pointers to commits. Let’s unpack it a bit more clearly:\n🧱 Commits: The Core Building Blocks\nEvery commit: Has a unique SHA-1 hash Stores a snapshot of the project Links to its parent(s), forming the project history All real data lives in the commit graph Without any branches, Git would still work — you’d just need to use hashes to refer to everything. 🏷️ Branches: Named Pointers to Commits\nA branch is a label that moves as you add commits Think of it as a bookmark: main → commit ABC123 📌 HEAD: The “Current Position” Pointer\nHEAD is just a pointer to: A branch (e.g., main) → which points to a commit Or directly to a commit (in detached mode) 📷 Tags: Static Pointers to Commits\nA tag is like a permanent label (e.g., v1.0) Unlike branches, tags don’t move 🧠 Mental Model\n[Commit A] ← [Commit B] ← [Commit C] ↑ main, HEAD Commits = data Branches/tags = labels HEAD = where you currently are\n9a3e6c2bd8c2fb4f09f7bbfe42f27f3853fccc60\n\n\n\n\n\n\n\n\nCommand\nSyntax\nDescription\n\n\n\n\nInitialize repo\ngit init\nCreates a new Git repository in the current directory\n\n\nClone repo\ngit clone &lt;url&gt;\nCopies a remote repository to your local machine\n\n\nCheck status\ngit status\nShows the current state of working directory and staging area\n\n\nStage changes\ngit add &lt;file&gt;\nAdds file(s) to the staging area\n\n\n\ngit add .\nStages all changes in the current directory\n\n\nUnstage file\ngit restore --staged &lt;file&gt;\nRemoves a file from the staging area\n\n\nDiscard changes\ngit restore &lt;file&gt;\nReverts file to last committed state\n\n\nCommit changes\ngit commit -m \"&lt;message&gt;\"\nSaves staged changes with a message\n\n\n\ngit commit --amend\nModifies the last commit (e.g., to fix message)\n\n\nView log\ngit log\nShows commit history\n\n\n\ngit log --oneline --graph\nCondensed log with branch structure\n\n\nView diff\ngit diff\nShows unstaged changes\n\n\n\ngit diff --staged\nShows staged vs last commit\n\n\nCreate branch\ngit branch &lt;name&gt;\nCreates a new branch\n\n\nSwitch branch\ngit switch &lt;name&gt;\nSwitches to another branch\n\n\n\ngit switch -c &lt;name&gt;\nCreates and switches to a new branch\n\n\nMerge branches\ngit merge &lt;branch&gt;\nMerges specified branch into current branch\n\n\nDelete branch\ngit branch -d &lt;name&gt;\nDeletes a branch (safe)\n\n\n\ngit branch -D &lt;name&gt;\nForces deletion of a branch\n\n\nView branches\ngit branch\nLists all local branches\n\n\nTrack remote branch\ngit branch -u origin/&lt;branch&gt;\nSets upstream for local branch\n\n\nPush changes\ngit push\nUploads commits to remote (default branch)\n\n\n\ngit push origin &lt;branch&gt;\nPushes a specific branch to remote\n\n\nPull changes\ngit pull\nFetches + merges changes from remote into current branch\n\n\nFetch only\ngit fetch\nDownloads changes from remote but doesn’t merge\n\n\nCheck remotes\ngit remote -v\nLists configured remotes and URLs\n\n\nTag a commit\ngit tag &lt;name&gt;\nTags the current commit\n\n\n\ngit tag -a &lt;name&gt; -m \"&lt;msg&gt;\"\nAnnotated tag with message\n\n\nCheckout commit\ngit checkout &lt;commit&gt;\nSwitches to a specific commit (detached HEAD)\n\n\nStash changes\ngit stash\nTemporarily saves uncommitted changes\n\n\n\ngit stash apply\nReapplies stashed changes\n\n\nView staged files\ngit ls-files --stage\nShows what’s in the staging area",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>GitHub & Collaboration</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html",
    "href": "07-internet-fundamentals.html",
    "title": "APIs & Internet Fundamentals",
    "section": "",
    "text": "The Internet\nWhat is the internet?\n“A series of tubes” is a phrase coined originally as an analogy by then-United States Senator Ted Stevens (R-Alaska) to describe the Internet in the context of opposing network neutrality.[1] On June 28, 2006, he used this metaphor to criticize a proposed amendment to a committee bill. The amendment would have prohibited Internet Access providers such as AT&T, Comcast, Time Warner Cable, and Verizon Communications from charging fees to give some companies’ data a higher priority in relation to other traffic.”\nWhat is the internet, really???\nThe Internet is a global system of interconnected computers and devices that communicate using standardized protocols—primarily the Internet Protocol Suite (TCP/IP)—to share information and services. These devices form a vast network-of-networks, exchanging data over physical infrastructure such as fiber-optic cables, satellites, and wireless technologies.\nThe Internet is a decentralized system where independently operated networks agree to exchange data.\nThe internet is a global network of devices connected via cables (fiber, copper, etc.), satellites, or wireless systems. Devices that connect to the internet communicate with each other by exchanging data using various sets of rules called protocols. Each protocol governs how a specific type of communication is carried out. For example, sending an email uses the SMTP protocol, while loading a webpage in your browser typically uses HTTPS.\nTherefore, when you open Gmail in your browser and send an email, multiple protocols are at work: HTTPS is used to load the Gmail web interface and securely interact with it, while SMTP is used behind the scenes to transmit the email to the recipient’s mail server.\nEach protocol has it’s own rules simliar to the grammar rules of a language (e.g. verb tense, sentence structure).\nJust as using proper grammar helps people understand each other clearly and effectively, the rules of a given protocol ensure that devices can reliably exchange a given type of data (e.g. email).\nOne of the most important protocols on the modern internet is HyperText Transfer Protocol Secure (HTTPS), which smartphones and laptops use—typically through web browsers—to securely interact with websites.\nWe dive into some of the rules later in this chapter.\nFirst, we need a better understanding for the kinds of devices that get connected to the Internet. When we say device, we mean any of the following:",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#the-internet",
    "href": "07-internet-fundamentals.html#the-internet",
    "title": "APIs & Internet Fundamentals",
    "section": "",
    "text": "Client devices – such as smartphones, laptops, tablets, and desktop computers that request data or services from servers.\nServers – computers (physical or virtual) that host websites, applications, files, or other data, and respond to client requests.\nRouters and switches – networking hardware that directs traffic across the internet and within local networks.\nInternet of Things (IoT) devices – smart thermostats, cameras, watches, appliances, and other gadgets that send and receive data.\nData center infrastructure – large-scale systems including virtual machines and containerized environments that power cloud services.\nEdge devices – equipment like content delivery nodes or local caching servers that bring data closer to users for faster access.\n\n\nClient\n\n\nServer\nWhat happens when you type a URL into a browser (e.g. Chrome, Safari)?\nSay you type: https://www.example.com into your browser.\nThis triggers a sequence of events involving several systems:\nStep 1: DNS Lookup\nDNS (Domain Name System) is the internet’s phonebook. Imagine a look-up table where every text URL is matched to the the IP address (a number that uniquely identifies the device or server).\nYou typed www.example.com. Your device asks a DNS server: “What is the IP address of this domain?” The DNS server replies with something like: 93.184.216.34. Now your computer knows where to send the request.\nStep 2: HTTP/HTTPS Request Now that you know the server’s address:\nYour browser sends an HTTP (or HTTPS) request to the IP address. This request says: “Please send me the web page for / (the homepage) of www.example.com.” If it’s HTTPS, the request is encrypted, so no one in between can read it.\nHTTP(S) stands for HyperText Transfer Protocol (Secure). A “protocol” is simply a formal set of rules for how computers communicate. Think of it like a shared language or etiquette for machines. These rules define how a client (like your browser) and a server (like example.com) exchange requests and responses.\nStep 3: Client-Server Architecture\nYour device (the client) made the request. The server (at 93.184.216.34) receives it, processes it, and sends back the necessary files — HTML, CSS, JavaScript, images, etc. You can think of this like a waiter (client) asking the kitchen (server) for your order (website) and bringing it back to your table (browser).\nStep 4: Browser Renders the Page\nYour browser receives the code and files. It renders the webpage visually — drawing the layout, loading images, executing JavaScript, and displaying the site\nBelow is a code snippet that illustrates\n\n\nExercise 1\n\nimport socket\nimport requests\n\n# Step 1: DNS Lookup\ndomain = \"example.com\"\nprint(f\"Looking up IP address for: {domain}\")\nip_address = socket.gethostbyname(domain)\nprint(f\"IP address of {domain} is {ip_address}\")\n\n# Step 2: HTTP Request\nprint(f\"\\nSending HTTP GET request to {domain}...\")\nprint(f\"\\nThe response is printed below:\")\nresponse = requests.get(f\"http://{domain}\")\n\n# Step 3: Print Response\nprint(f\"\\nResponse Status Code: {response.status_code}\")\nprint(f\"\\nCode of 200 means things went as planned.\")\nprint(\"Response Headers:\")\nprint(response.headers)\n\nprint(\"\\nFirst 500 characters of the HTML:\")\nprint(response.text)\n\n# Step 4: Save response to an HTML file\nfilename = \"response.html\"\nwith open(filename, \"w\", encoding=\"utf-8\") as f:\n    f.write(response.text)\n\nprint(f\"\\nFull HTML response saved to {filename}.\")\nprint(f\"\\nOpen the HTML file in your browser.\")\n\n\n\n\n\n\n\nWhat are Response Status Code?\n\n\n\n\n\nHTTP response codes are standardized 3-digit numbers sent by a web server to indicate the outcome of a client’s request. They let the client know whether the request was successful, redirected, resulted in an error, or requires additional action.\nTwo of the most common codes you will encounter are 200 and 404.\n\n\n\n\n\n\n\n\n\nCode Category\nCode\nName\nDescription\n\n\n\n\n1xx Informational\n100\nContinue\nThe initial part of the request has been received, and the client should continue.\n\n\n\n101\nSwitching Protocols\nServer is switching protocols as requested (e.g., HTTP to WebSocket).\n\n\n2xx Success\n200\nOK\nThe request succeeded, and the response contains the requested data.\n\n\n\n201\nCreated\nA new resource was successfully created (e.g., after a POST request).\n\n\n\n202\nAccepted\nThe request has been received but not yet processed.\n\n\n\n204\nNo Content\nThe request was successful, but there is no content to return.\n\n\n3xx Redirection\n301\nMoved Permanently\nThe resource has permanently moved to a new URL.\n\n\n\n302\nFound\nThe resource is temporarily at a different URL.\n\n\n\n304\nNot Modified\nThe cached version is still valid; no need to resend data.\n\n\n4xx Client Errors\n400\nBad Request\nThe server couldn’t understand the request due to malformed syntax.\n\n\n\n401\nUnauthorized\nAuthentication is required or failed.\n\n\n\n403\nForbidden\nThe server understands the request but refuses to authorize it.\n\n\n\n404\nNot Found\nThe requested resource could not be found.\n\n\n\n405\nMethod Not Allowed\nThe HTTP method is not supported for this resource.\n\n\n5xx Server Errors\n500\nInternal Server Error\nA generic server error — something went wrong on the server.\n\n\n\n502\nBad Gateway\nThe server received an invalid response from an upstream server.\n\n\n\n503\nService Unavailable\nThe server is temporarily unavailable (e.g., overloaded or down for maintenance).\n\n\n\n504\nGateway Timeout\nThe upstream server failed to respond in time.\n\n\n\n\n\n\n\n\n\n\n\n\nWhat are Response Headers?\n\n\n\n\n\nHeaders are a core part of the HTTP protocol (i.e. the agreed upon rules of sending information across the internet). Headers take the form of key-value pairs which are sent between a client and server and carry metadata about the request or response (e.g. such as content type, caching rules, and encoding). Headers help browsers and servers understand how to handle the data being exchanged. Below is a description of the headers that were returned from the example above.\n\n\n\n\n\n\n\nHeader (key: value pair)\nMeaning\n\n\n\n\nAccept-Ranges: bytes\nThe server supports partial content downloads (e.g., resuming a download from a byte offset).\n\n\nContent-Type: text/html\nThe response body is HTML — browsers know to render it as a webpage.\n\n\nETag\nA unique ID (hash) representing this specific version of the file. Used for efficient caching.\n\n\nLast-Modified\nTimestamp of the last modification to the resource. Useful for cache validation.\n\n\nVary: Accept-Encoding\nIndicates that the response varies depending on how the client encodes requests (e.g., gzip).\n\n\nContent-Encoding: gzip\nThe response is compressed using gzip. The browser will decompress it automatically.\n\n\nContent-Length: 648\nSize of the response body in bytes after compression.\n\n\nCache-Control: max-age=3241\nTells the browser it can cache this resource for 3,241 seconds (~54 minutes).\n\n\nDate\nThe date and time when the response was generated by the server.\n\n\nConnection: keep-alive\nKeeps the TCP connection open for reuse, improving performance for multiple requests.\n\n\n\n\n\n\n\n\nHTTP/HTTPS\nEalier we said that a “protocol” is simply a formal set of rules for how computers communicate (exchange requests and responses). Let’s look at what some of those rules are.\nIn the HTTP protocol, the commands used to tell the server what action the client wants to perform are called HTTP methods (or sometimes “verbs”)\nThe HTTP protocol includes:\nRules for message structure (request/response format) Allowed methods (GET, POST, etc.) Status codes (200, 404, 500, etc.) Headers (metadata) Optional message body Rules for connection management (e.g., keep-alive)",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#what-is-the-internet",
    "href": "07-internet-fundamentals.html#what-is-the-internet",
    "title": "APIs & Internet Fundamentals",
    "section": "What IS the Internet?",
    "text": "What IS the Internet?\nThe internet is a global network of interconnected computers that communicate using standardized protocols. When you’re building digital products, you’re essentially building on top of this massive infrastructure.\nThink of it as three layers:\n\nPhysical layer: Cables, fiber optics, wireless signals, satellites\nNetwork layer: Routers, switches, and protocols that move data\n\nApplication layer: Websites, apps, and services — this is where your products live",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#key-infrastructure-components",
    "href": "07-internet-fundamentals.html#key-infrastructure-components",
    "title": "APIs & Internet Fundamentals",
    "section": "Key Infrastructure Components",
    "text": "Key Infrastructure Components\n\nInternet Service Providers (ISPs)\n\nTier 1: Backbone providers (AT&T, Verizon, Level 3)\nTier 2: Regional providers that buy from Tier 1\nTier 3: Local ISPs that serve consumers\n\nWhen users complain about slow loading, it’s often their ISP, not your app. This hierarchy affects how you think about hosting locations and performance expectations.\n\n\nData Centers & The Cloud\n\nMassive server farms around the world\nContent Delivery Networks (CDNs) — bring content closer to users\nEdge computing — processing data closer to where it’s generated\n\nModern apps distribute globally through CDNs and multiple regions. If AWS US-East goes down (and it does), your European users keep working. AI processing at the edge means lower latency for real-time features.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#essential-protocols-technologies",
    "href": "07-internet-fundamentals.html#essential-protocols-technologies",
    "title": "APIs & Internet Fundamentals",
    "section": "Essential Protocols & Technologies",
    "text": "Essential Protocols & Technologies\n\nDNS (Domain Name System)\n\nWhat it does: Translates google.com → 142.250.190.78\nWhy it matters: Humans remember names, computers need numbers\nHow it works: Hierarchical system of DNS servers worldwide\n\nDNS is often the invisible bottleneck. Slow DNS makes your app feel slow even when your servers are blazing fast. Smart founders use multiple DNS providers and aggressive caching.\n\n\nIP Addresses & Routing\n\nIPv4: 192.168.1.1 (we’re running out of these)\nIPv6: 2001:0db8:85a3::8a2e:0370:7334 (the inevitable future)\nRouting: How data finds the best path across networks\n\nThe IPv4 shortage means higher hosting costs and eventual IPv6 migration. Geographic routing lets you serve users from the closest servers.\n\n\nTCP/IP Stack\n\nApplication Layer: HTTP, HTTPS, FTP, SMTP — your APIs live here\nTransport Layer: TCP (reliable) vs UDP (fast)\nInternet Layer: IP routing and addressing\nPhysical Layer: Actual cables and wireless signals\n\nHTTPS is no longer optional — it’s required for user trust, SEO, and modern browser features. Choose TCP for payments and critical data, UDP for gaming and real-time features where speed beats reliability.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#watch-this-video-for-the-big-picture",
    "href": "07-internet-fundamentals.html#watch-this-video-for-the-big-picture",
    "title": "APIs & Internet Fundamentals",
    "section": "Watch this video for the big picture:",
    "text": "Watch this video for the big picture:",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#step-by-step-what-happens-when-you-visit-a-website",
    "href": "07-internet-fundamentals.html#step-by-step-what-happens-when-you-visit-a-website",
    "title": "APIs & Internet Fundamentals",
    "section": "Step-by-step: What happens when you visit a website",
    "text": "Step-by-step: What happens when you visit a website\n\nThe Journey of a Web Request\n\nYou type google.com into your browser\nDNS lookup: Your computer asks “What’s the IP address for google.com?”\n\nChecks local cache first\nAsks your ISP’s DNS server\nMay query root servers, then .com servers, then Google’s servers\n\nDNS response: Returns something like 142.250.190.78\nTCP handshake: Your computer establishes a reliable connection\n\nSYN: “Can we talk?”\nSYN-ACK: “Yes, let’s talk”\nACK: “Great, let’s start”\n\nHTTP request: Your browser sends a request http  GET / HTTP/1.1  Host: google.com  User-Agent: Mozilla/5.0...\nServer processing: Google’s server processes your request\nHTTP response: Server sends back HTML, CSS, JavaScript\nBrowser rendering: Your browser assembles and displays the page\nAdditional requests: Browser fetches images, stylesheets, scripts\n\n\n\nWhy This Matters for Developers\nUnderstanding this flow helps you: - Debug performance issues — where are the bottlenecks? - Optimize loading times — reduce DNS lookups, use CDNs - Handle errors gracefully — network timeouts, DNS failures - Design better APIs — minimize round trips, cache effectively",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#the-modern-internet-architecture",
    "href": "07-internet-fundamentals.html#the-modern-internet-architecture",
    "title": "APIs & Internet Fundamentals",
    "section": "The Modern Internet Architecture",
    "text": "The Modern Internet Architecture\n\nContent Delivery Networks (CDNs)\nInstead of everyone hitting one server, CDNs distribute content globally:\nUser in Tokyo → Tokyo CDN server (fast!)\nUser in London → London CDN server (fast!)\nUser in NYC → NYC CDN server (fast!)\nA user in Australia waiting 2 seconds for your US server vs. 0.2 seconds for a Sydney CDN server — that 10x difference shows up in conversion rates.\nPopular CDNs: Cloudflare (free tier), AWS CloudFront, Google Cloud CDN\n\n\nLoad Balancers\nDistribute traffic across multiple servers: - Round robin: Request 1 → Server A, Request 2 → Server B - Least connections: Send to server with fewest active connections - Geographic: Route based on user location\nWhen one server crashes, load balancers route to healthy ones. When traffic spikes, they distribute the load. Essential for anything beyond a side project.\n\n\nMicroservices & APIs\nModern apps aren’t monoliths — they’re collections of services:\nFrontend App → Authentication API\n            → User Profile API  \n            → Payment API\n            → Notification API\nThis architecture lets you scale what matters, gives teams independence, and makes debugging easier. Problem with payments? Check the payment service logs, not the entire application.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#api-in-plain-english",
    "href": "07-internet-fundamentals.html#api-in-plain-english",
    "title": "APIs & Internet Fundamentals",
    "section": "API in plain English",
    "text": "API in plain English\nAPI = Application Programming Interface\nIt’s a set of rules for how software talks to other software.\nRestaurant analogy:\n- The API is the waiter\n- Your app is the customer\n- The kitchen is the server\n- The menu is what’s available via the API\nYour app sends a request → API delivers it → response comes back.\nInstead of building a payment processor from scratch, you use Stripe’s API. Instead of training your own AI model, you call OpenAI’s API. APIs let you focus on what makes your product unique while leveraging existing solutions for everything else.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#when-youll-need-api-keys",
    "href": "07-internet-fundamentals.html#when-youll-need-api-keys",
    "title": "APIs & Internet Fundamentals",
    "section": "When you’ll need API keys",
    "text": "When you’ll need API keys\n\nOpenAI — for AI features\nZapier workflows — for automation\n\nFrontend to backend — your app’s internal communication\nStripe — for payments\nSendGrid — for emails\nAnalytics services — for tracking\n\nMost apps end up with 10+ API keys pretty quickly. Each one represents functionality you’re getting instantly instead of building over months.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#example-request-header",
    "href": "07-internet-fundamentals.html#example-request-header",
    "title": "APIs & Internet Fundamentals",
    "section": "Example request header",
    "text": "Example request header\nAuthorization: Bearer sk-abc123",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#api-authentication-methods",
    "href": "07-internet-fundamentals.html#api-authentication-methods",
    "title": "APIs & Internet Fundamentals",
    "section": "API Authentication Methods",
    "text": "API Authentication Methods\nBeyond API keys, you’ll encounter these authentication methods:\n\nOAuth 2.0 — for accessing user data from platforms like Google, GitHub, Twitter\nJWT (JSON Web Tokens) — for stateless authentication in your own APIs\nBearer tokens — commonly used with AI services",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#api-security-basics",
    "href": "07-internet-fundamentals.html#api-security-basics",
    "title": "APIs & Internet Fundamentals",
    "section": "API Security Basics",
    "text": "API Security Basics\n\nNever hardcode API keys — use environment variables\nRotate keys regularly — especially if compromised\nUse HTTPS always — never send keys over HTTP\nRespect rate limits — avoid getting blocked",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#common-tools-youll-use",
    "href": "07-internet-fundamentals.html#common-tools-youll-use",
    "title": "APIs & Internet Fundamentals",
    "section": "Common tools you’ll use:",
    "text": "Common tools you’ll use:\n\nAI & ML APIs\n\nOpenAI API — GPT models for text generation, summarization, chat\nAnthropic Claude — advanced reasoning and analysis\nHugging Face — open-source models and transformers\nGoogle Cloud AI — vision, translation, speech recognition\n\n\n\nAutomation & Integration\n\nZapier — to automate tasks (like sending data to Slack or Sheets)\n\nWebhooks — real-time notifications when events happen\n\n\n\nData & Backend\n\nFirebase / Supabase — to store and manage your app’s data\n\nYour own custom API — to connect your app’s frontend to its backend logic\n\n\n\nPayments & Business\n\nStripe API — to handle payments, billing, and subscriptions",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#whats-a-chatgpt-wrapper",
    "href": "07-internet-fundamentals.html#whats-a-chatgpt-wrapper",
    "title": "APIs & Internet Fundamentals",
    "section": "What’s a “ChatGPT Wrapper”?",
    "text": "What’s a “ChatGPT Wrapper”?\nYou’ll hear this term a lot in startup circles. A ChatGPT wrapper is essentially an app that:\n\nTakes user input through a custom interface\nSends that input to OpenAI’s API behind the scenes\nFormats and presents the response in a specific way\nOften adds specialized prompts, context, or processing\n\nExamples of successful wrappers: - Copy.ai — marketing copy generation - Jasper — content writing for businesses\n- Notion AI — writing assistance within Notion - GitHub Copilot — code completion in your editor\nWhy wrappers work: - Specialized UI — better than ChatGPT’s generic interface for specific tasks - Custom prompts — pre-engineered for particular use cases - Integration — built into existing workflows - Branding — your product, not OpenAI’s\nThe business model: You pay OpenAI ~$0.002 per 1K tokens, charge users $20-50/month for unlimited access to your specialized interface.\n\nAutomate workflows with Zapier\nWhen new users sign up, auto-send welcome email + add to CRM + notify team in Slack\nProcess payments with Stripe\nCharge credit cards, manage subscriptions, send receipts, handle refunds\nBuild a backend API for your app\nLet your frontend make requests like GET /tasks or POST /user\nTrack everything with analytics APIs\nUser behavior, conversion rates, feature usage\nSend emails with SendGrid/Mailgun\nWelcome sequences, password resets, marketing campaigns",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#restful-api-conventions",
    "href": "07-internet-fundamentals.html#restful-api-conventions",
    "title": "APIs & Internet Fundamentals",
    "section": "RESTful API Conventions",
    "text": "RESTful API Conventions\nWhen building your own APIs, follow these patterns:\n\nGET /users — retrieve all users\nGET /users/123 — retrieve specific user\nPOST /users — create new user\nPUT /users/123 — update user\nDELETE /users/123 — delete user",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#error-handling",
    "href": "07-internet-fundamentals.html#error-handling",
    "title": "APIs & Internet Fundamentals",
    "section": "Error Handling",
    "text": "Error Handling\nYour API should return meaningful error codes:\n{\n  \"error\": \"User not found\",\n  \"code\": 404,\n  \"message\": \"No user exists with ID 123\"\n}",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#api-documentation",
    "href": "07-internet-fundamentals.html#api-documentation",
    "title": "APIs & Internet Fundamentals",
    "section": "API Documentation",
    "text": "API Documentation\nAlways document your APIs using tools like: - Swagger/OpenAPI — interactive documentation - Postman Collections — shareable API examples - ReadMe — beautiful documentation sites",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#security-privacy-best-practices",
    "href": "07-internet-fundamentals.html#security-privacy-best-practices",
    "title": "APIs & Internet Fundamentals",
    "section": "Security & Privacy Best Practices",
    "text": "Security & Privacy Best Practices\n\nSecret Key Management\n\nNever hardcode API keys — use environment variables (.env files)\nRotate keys regularly — especially if compromised\nUse different keys for different environments — dev, staging, production\nStore secrets securely — use services like AWS Secrets Manager, HashiCorp Vault\nAdd .env to .gitignore — never commit secrets to version control\n\n\n\nPrivacy & Data Protection\n\nMinimize data collection — only request what you actually need\nEncrypt data in transit — always use HTTPS/TLS\nEncrypt sensitive data at rest — especially user data, payment info\nImplement proper access controls — not everyone needs admin API keys\nLog carefully — never log API keys, passwords, or sensitive user data\nGDPR/CCPA compliance — understand data retention and deletion requirements\n\n\n\nAPI Communication Security\n\nUse HTTPS always — never send keys over HTTP\nValidate all inputs — prevent injection attacks\nImplement rate limiting — protect against abuse and DDoS\nUse API versioning — maintain backward compatibility\nMonitor API usage — detect unusual patterns or potential breaches\n\n\n\nWhen Things Go Wrong\n\nHave an incident response plan — what to do if keys are compromised\nMonitor for leaked secrets — tools like GitGuardian can scan your repos\nAudit API access regularly — who has access to what keys\nDocument your security practices — for compliance and team onboarding\n\nA leaked Stripe key means unauthorized charges. A compromised OpenAI key means someone burns through your AI budget. Poor privacy practices can lead to regulatory fines and lost user trust. Environment variable mistakes have cost founders thousands overnight.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#build-your-first-ai-powered-api",
    "href": "07-internet-fundamentals.html#build-your-first-ai-powered-api",
    "title": "APIs & Internet Fundamentals",
    "section": "Build Your First AI-Powered API",
    "text": "Build Your First AI-Powered API\nGoal: Create a simple API that summarizes text using OpenAI\nWhy this exercise matters: This is the exact pattern you’ll use to build AI features into your product. Master this, and you can add AI to anything.\n\nStep 1: Set up your environment\nnpm init -y\nnpm install express openai dotenv\n\n\nStep 2: Create your API\n// server.js\nconst express = require('express');\nconst OpenAI = require('openai');\nrequire('dotenv').config();\n\nconst app = express();\napp.use(express.json());\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY\n});\n\napp.post('/summarize', async (req, res) =&gt; {\n  try {\n    const { text } = req.body;\n    \n    const completion = await openai.chat.completions.create({\n      model: \"gpt-3.5-turbo\",\n      messages: [\n        {\n          role: \"user\",\n          content: `Summarize this text: ${text}`\n        }\n      ]\n    });\n    \n    res.json({\n      summary: completion.choices[0].message.content\n    });\n  } catch (error) {\n    res.status(500).json({\n      error: \"Failed to summarize text\",\n      message: error.message\n    });\n  }\n});\n\napp.listen(3000, () =&gt; {\n  console.log('API running on port 3000');\n});\n\n\nStep 3: Test your API\ncurl -X POST http://localhost:3000/summarize \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"text\": \"Your long text here...\"}'",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#api-pricing-models",
    "href": "07-internet-fundamentals.html#api-pricing-models",
    "title": "APIs & Internet Fundamentals",
    "section": "API Pricing Models",
    "text": "API Pricing Models\n\nPer request — OpenAI charges per token\nMonthly subscription — Zapier has monthly limits\nUsage tiers — Stripe charges percentage + fixed fee",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#when-to-build-vs.-buy",
    "href": "07-internet-fundamentals.html#when-to-build-vs.-buy",
    "title": "APIs & Internet Fundamentals",
    "section": "When to Build vs. Buy",
    "text": "When to Build vs. Buy\nBuild your own API when: - You need custom business logic - You want full control over data - Third-party options are too expensive\nUse third-party APIs when: - The functionality already exists - It’s not core to your business - You need to move fast",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#rest-vs.-graphql",
    "href": "07-internet-fundamentals.html#rest-vs.-graphql",
    "title": "APIs & Internet Fundamentals",
    "section": "REST vs. GraphQL",
    "text": "REST vs. GraphQL\nREST (what we’ve covered): - Simple and widely supported - Good for CRUD operations - Easy to cache\nGraphQL: - Request exactly the data you need - Single endpoint for all operations - Better for complex, nested data",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#webhooks-real-time-apis",
    "href": "07-internet-fundamentals.html#webhooks-real-time-apis",
    "title": "APIs & Internet Fundamentals",
    "section": "Webhooks & Real-time APIs",
    "text": "Webhooks & Real-time APIs\nInstead of constantly asking “is there new data?”, webhooks push data to you:\n// Stripe webhook example\napp.post('/webhook/stripe', (req, res) =&gt; {\n  const event = req.body;\n  \n  if (event.type === 'payment_intent.succeeded') {\n    // User paid! Update your database\n    console.log('Payment received:', event.data.object);\n  }\n  \n  res.json({received: true});\n});",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#why-this-matters",
    "href": "07-internet-fundamentals.html#why-this-matters",
    "title": "APIs & Internet Fundamentals",
    "section": "Why this matters:",
    "text": "Why this matters:\nAPIs let you scale your product, connect tools, and automate workflows — without reinventing the wheel.\nUsing APIs well means: - Faster development — don’t rebuild what exists - Cleaner architecture — separate concerns properly - Lower engineering costs — leverage existing infrastructure - Better user experience — integrate best-in-class services",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "07-internet-fundamentals.html#key-takeaways-for-founders",
    "href": "07-internet-fundamentals.html#key-takeaways-for-founders",
    "title": "APIs & Internet Fundamentals",
    "section": "Key Takeaways for Founders",
    "text": "Key Takeaways for Founders\n\nStart with third-party APIs — build your MVP faster\nPlan for scale — understand pricing and rate limits\nDocument everything — your future self will thank you\nSecurity first — protect your keys and user data\nMonitor and optimize — track API costs and performance\n\nThese are mission-critical skills for anyone building or launching a tech product.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>APIs & Internet Fundamentals</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html",
    "href": "08-software-engineering.html",
    "title": "SWE Principles",
    "section": "",
    "text": "Types of Digital Applications",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#types-of-digital-applications",
    "href": "08-software-engineering.html#types-of-digital-applications",
    "title": "SWE Principles",
    "section": "",
    "text": "1. System Software\nOperating systems, device drivers, and utilities that manage hardware and core system functions (e.g., Windows, Linux, macOS).\n\n\n2. Embedded Software\nRuns on specialized hardware such as IoT devices, vehicles, and appliances (e.g., firmware in smart thermostats or car infotainment systems).\n\n\n3. APIs and Microservices (Supporting Components)\nBackend services and interfaces that enable communication and integration between applications (e.g., Stripe API, AWS Lambda).\n\n\n4. Cloud-Based Applications / SaaS\nApplications accessed over the internet, often subscription-based and scalable (e.g., Salesforce, Zoom, Dropbox).\n\n\n5. Web Applications\nApps accessed via a browser, including: - Standard web apps – Gmail, Google Docs, Netflix. - Progressive Web Apps (PWAs) – Hybrid apps with offline support and installability (e.g., Twitter Lite).\n\n\n6. Desktop Applications\nInstalled software for personal computers (e.g., Photoshop, Microsoft Word, Spotify desktop).\n\n\n7. Mobile Applications\nNative or cross-platform apps for smartphones and tablets (e.g., Instagram, Uber, Duolingo).",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#introduction-thinking-like-a-software-engineer",
    "href": "08-software-engineering.html#introduction-thinking-like-a-software-engineer",
    "title": "SWE Principles",
    "section": "Introduction: Thinking like a Software Engineer",
    "text": "Introduction: Thinking like a Software Engineer\nWhat comes to mind when you think of software engineering? Most people immediately think of one thing–writing code. However, “writing code” does not fully encapsulate the work of a software engineer. At its core, software engineering is all about designing solutions to complex problems in a way that others can understand and improve upon over time. Whether you’re building a personal project or contributing to a larger application, you should always keep these four essential questions in mind:\n\nCan others understand my code? Will someone else (or future you) be able to read and modify this code easily?\nIs it scalable? As my user base grows, will my code still work efficiently?\nDoes it handle errors? When something goes wrong, does my code deal with it gracefully instead of crashing?\nDoes it work fast? Is my code efficient and doesn’t waste computer resources?\n\nUnderstanding the fundamentals of software engineering is essential to allow you to use AI to its fullest capacity. This chapter explores those fundamental ideas and best practices needed to write robust and maintainable code.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#programming-basics",
    "href": "08-software-engineering.html#programming-basics",
    "title": "SWE Principles",
    "section": "Programming Basics",
    "text": "Programming Basics\n\nVariables, Functions, Conditionals, Loops\nThe building blocks of any program are variables, functions, conditionals, and loops. Below is a brief introduction to each programming concept, along with some practical examples:\n\n** About the Code Examples**\nIn the code examples throughout this chapter, we will use JavaScript with Next.js, a popular React framework for building modern web applications. Keep in mind though, any programming language will adhere to the same fundamental principles, though the syntax may vary.\n\nVariables store data in your program. Choose descriptive names that clearly indicate what the variable contains:\n// Good - Names clearly describe what the data represents\nconst userAge = 25;                    // Age of the user\nconst isAuthenticated = true;          // Whether user is logged in\nconst customerEmail = \"john@example.com\"; // User's email address\n\n// Poor - Unclear names that don't explain the data\nconst x = 25;        // What does x represent?\nconst flag = true;   // What is this flag for?\nconst data = \"john@example.com\"; // What kind of data?\nFunctions are reusable blocks of code that perform specific tasks. Good functions follow these principles:\n// This function has one clear job: calculate a price with tax and discount\n// It takes three inputs (parameters) and returns the final price\nfunction calculateTotalPrice(basePrice, taxRate, discountPercentage = 0) {\n    // First, apply the discount (if any)\n    const discountedPrice = basePrice * (1 - discountPercentage / 100);\n    \n    // Then, add tax to the discounted price\n    const totalWithTax = discountedPrice * (1 + taxRate);\n    \n    // Round to 2 decimal places for currency display\n    return Math.round(totalWithTax * 100) / 100;\n}\n\n// Usage example:\nconst finalPrice = calculateTotalPrice(100, 0.08, 10); // $100 base, 8% tax, 10% discount\nconsole.log(finalPrice); // Result: $97.20\nConditionals let your program make decisions based on different situations:\n// Check user's age and respond appropriately\nif (userAge &gt;= 18) {\n    console.log(\"User is an adult\");\n} else if (userAge &gt;= 13) {\n    console.log(\"User is a teenager\");\n} else {\n    console.log(\"User is a child\");\n}\n\n// This creates different behavior based on the userAge value\n// 25 → \"User is an adult\"\n// 16 → \"User is a teenager\" \n// 8 → \"User is a child\"\nLoops repeat actions efficiently instead of writing the same code multiple times:\n// For loop: when you know exactly how many times to repeat\nfor (let i = 0; i &lt; 5; i++) {\n    console.log(`Iteration ${i}`); // Prints: Iteration 0, Iteration 1, etc.\n}\n\n// While loop: when you repeat until a condition is met\nlet userInput = \"\";\nwhile (userInput !== \"quit\") {\n    userInput = prompt(\"Enter command (or 'quit' to exit): \");\n    processCommand(userInput);\n}\n// This keeps asking for input until the user types \"quit\"\n\n\nComponents in Next.js\nIn Next.js, components are like custom LEGO blocks for building websites. Each component is a piece of your website that can be reused and combined with other pieces.\nThink of a component like a recipe that describes: - What it looks like (the display) - What data it needs (like ingredients) - What it can do (like buttons that respond to clicks)\nLet’s look at a simple example - a counter component that can be used on any page:\n// components/Counter.js\nimport { useState } from 'react';\n\n// This is a Counter component - it's like creating a new type of element\nexport default function Counter() {\n    // This is \"state\" - data that can change over time\n    // We start counting at 0\n    const [count, setCount] = useState(0);\n    \n    // These are functions that change our count\n    const increase = () =&gt; {\n        setCount(count + 1); // Add 1 to current count\n    };\n    \n    const decrease = () =&gt; {\n        setCount(count - 1); // Subtract 1 from current count\n    };\n    \n    // This describes what appears on the screen\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;Counter: {count}&lt;/h2&gt;\n            &lt;button onClick={increase}&gt;+&lt;/button&gt;\n            &lt;button onClick={decrease}&gt;-&lt;/button&gt;\n        &lt;/div&gt;\n    );\n}\nUsing the component in a Next.js App Router page:\n// app/page.js (Home page)\nimport Counter from '../components/Counter';\n\nexport default function HomePage() {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;Welcome to My App&lt;/h1&gt;\n            &lt;Counter /&gt;\n        &lt;/div&gt;\n    );\n}\nWhat’s happening here: 1. useState(0) creates a variable called count that starts at 0 2. setCount is how we change the value of count 3. When someone clicks the + button, count increases by 1 4. When someone clicks the - button, count decreases by 1 5. The screen automatically updates to show the new number 6. export default makes the component available to import in other files\nMaking components reusable with props:\n// components/UserCard.js\nexport default function UserCard({ name, age, email }) {\n    return (\n        &lt;div style={{ border: '1px solid #ccc', padding: '16px', margin: '8px' }}&gt;\n            &lt;h3&gt;{name}&lt;/h3&gt;\n            &lt;p&gt;Age: {age}&lt;/p&gt;\n            &lt;p&gt;Email: {email}&lt;/p&gt;\n        &lt;/div&gt;\n    );\n}\n\n// Usage in a page:\n// &lt;UserCard name=\"Alice\" age={25} email=\"alice@example.com\" /&gt;\n// &lt;UserCard name=\"Bob\" age={30} email=\"bob@example.com\" /&gt;\nNext.js App Router benefits: - File-based routing: Folders become routes, page.js files become pages - Layouts and templates: Shared UI components that wrap multiple pages - Built-in optimization: Images, fonts, and scripts are optimized automatically - Server and client components: Better performance with server-side rendering - API routes: Backend and frontend in the same project - Easy deployment: One command deploys your entire app",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#command-line-fundamentals",
    "href": "08-software-engineering.html#command-line-fundamentals",
    "title": "SWE Principles",
    "section": "Command Line Fundamentals",
    "text": "Command Line Fundamentals\nThe command line is your direct interface to the computer’s operating system. It’s faster than clicking through menus once you learn the basics.\n\nEssential Commands\ncd (Change Directory) - Navigate between folders:\ncd /path/to/your/project    # Go to a specific folder\ncd ..                       # Go up one level (to parent folder)\ncd ~                        # Go to your home directory\ncd -                        # Go back to the previous directory\nls (List) - See what’s in the current folder:\nls                          # Show files and folders\nls -la                      # Show detailed info including hidden files\nls *.py                     # Show only Python files\nmkdir (Make Directory) - Create new folders:\nmkdir new-project           # Create a single folder\nmkdir -p projects/web/app   # Create nested folders all at once\nAdditional Useful Commands:\npwd                         # Show current folder path\nrm filename                 # Delete a file\nrm -rf foldername          # Delete a folder and everything in it\ncp source destination       # Copy files\nmv source destination       # Move or rename files\n\n\nCommand Line Tips\n\nTab completion: Start typing a filename and press Tab to auto-complete\nUp arrow: Recalls your previous commands\nCtrl+C: Stops a running command\nman command: Shows the manual for any command (e.g., man ls)",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#project-setup-and-structure",
    "href": "08-software-engineering.html#project-setup-and-structure",
    "title": "SWE Principles",
    "section": "Project Setup and Structure",
    "text": "Project Setup and Structure\n\nHow to Create a New Project\nStarting with good organization prevents headaches later. Here’s the standard workflow:\n1. Create the project folder:\nmkdir my-awesome-project    # Create main folder\ncd my-awesome-project       # Enter the folder\n2. Set up version control:\ngit init                    # Initialize Git tracking\n3. Create basic structure:\nmkdir src                   # Source code goes here\nmkdir tests                 # Test files go here\nmkdir docs                  # Documentation goes here\ntouch README.md             # Project description file\ntouch .gitignore            # Files to ignore in Git\n4. Set up for Next.js:\n# Create a new Next.js project (recommended)\nnpx create-next-app@latest my-awesome-project\ncd my-awesome-project\n\n# Or manual setup (advanced users)\nnpm init -y\nnpm install next react react-dom\n\n\nFile Structure (One Class/Component per File)\nOrganize your code so each file has one main purpose. This makes finding and fixing code much easier. Below is an example of how you might organize your codebase:\nmy-nextjs-project/\n├── app/                   # App Router (Next.js 13+)\n│   ├── layout.js         # Root layout component\n│   ├── page.js           # Home page (/)\n│   ├── globals.css       # Global styles\n│   ├── login/            # Login page route\n│   │   └── page.js       # Login page (/login)\n│   ├── products/         # Products route group\n│   │   ├── page.js       # Products list (/products)\n│   │   └── [id]/         # Dynamic route\n│   │       └── page.js   # Individual product (/products/123)\n│   └── api/              # API routes (backend)\n│       ├── users/        # /api/users endpoint\n│       │   └── route.js  # API handler\n│       └── orders/       # /api/orders endpoint\n│           └── route.js  # API handler\n├── components/           # Reusable UI components\n│   ├── User.js          # User component\n│   ├── Product.js       # Product component\n│   └── Order.js         # Order component\n├── lib/                 # Business logic and utilities\n│   ├── userService.js   # User-related operations\n│   ├── emailService.js  # Email functionality\n│   ├── paymentService.js # Payment processing\n│   └── utils.js         # General helper functions\n├── styles/              # Additional CSS files\n│   └── components.css   # Component-specific styles\n├── public/              # Static files\n│   ├── favicon.ico      # Website icon\n│   └── images/          # Image assets\n├── __tests__/           # Test files\n│   ├── components/      # Component tests\n│   │   └── User.test.js\n│   ├── app/            # Page tests\n│   │   └── page.test.js\n│   └── lib/            # Service tests\n│       └── userService.test.js\n├── README.md            # Project documentation\n├── package.json         # Dependencies and scripts\n├── next.config.js       # Next.js configuration\n└── .gitignore          # Files to ignore in version control\nWhy this file structure works: - Clear separation: Components, logic, and styles are organized separately - Easy navigation: Need user functionality? Look in User.js or userService.js - Prevents conflicts: Team members can work on different files without interfering - Easier testing: Test files directly correspond to source files",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#running-your-project-locally",
    "href": "08-software-engineering.html#running-your-project-locally",
    "title": "SWE Principles",
    "section": "Running Your Project Locally",
    "text": "Running Your Project Locally\n\nLocalhost\nLocalhost is your computer pretending to be a web server. It lets you test your website before publishing it to the internet.\nStarting your local Next.js server:\n# For Next.js projects:\nnpm run dev                 # Starts Next.js development server on port 3000\n\n# For production build testing:\nnpm run build               # Build the app for production\nnpm start                   # Start production server\n\n# For static export:\nnpm run build && npm run export  # Generate static files\nWhat happens when you run npm run dev: 1. The Next.js development server starts 2. Your browser opens to http://localhost:3000 3. You can see your app running locally 4. Changes you make automatically refresh the page (Hot Reload) 5. API routes are available at http://localhost:3000/api/...\nLocal Development Tips: - Use environment variables for settings (database URLs, API keys) - Keep local and production environments similar - Use different ports for different services to avoid conflicts",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#version-control-with-git",
    "href": "08-software-engineering.html#version-control-with-git",
    "title": "SWE Principles",
    "section": "Version Control with Git",
    "text": "Version Control with Git\nGit tracks changes to your code over time, like a detailed history of your project. It lets you experiment safely and collaborate with others. Learning to use version control is a crucial part of managing any software project. See the following video for a brief introduction to git:\nhttps://www.youtube.com/watch?v=r8jQ9hVA2qs\nSee the Github and Collaboration chapter for more detailed information on using Git and Github.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#debugging-and-error-handling",
    "href": "08-software-engineering.html#debugging-and-error-handling",
    "title": "SWE Principles",
    "section": "Debugging and Error Handling",
    "text": "Debugging and Error Handling\n\nHow to Handle Errors\nGood programs expect things to go wrong and handle problems gracefully instead of crashing.\nTry-catch blocks handle errors that might occur:\n// This function tries to do something risky and handles problems\nfunction processUserData(userData) {\n    try {\n        // This might fail if userData is invalid\n        const result = parseUserInput(userData);\n        const processedData = transformData(result);\n        return processedData;\n        \n    } catch (error) {\n        // Handle specific types of errors differently\n        if (error instanceof ValidationError) {\n            console.error(`User input invalid: ${error.message}`);\n            return null; // Return safe default\n        } else {\n            console.error(`Unexpected error: ${error.message}`);\n            throw error; // Re-throw unknown errors\n        }\n        \n    } finally {\n        // This code runs whether success or failure\n        cleanupTempFiles();\n    }\n}\nInput validation checks data before using it:\nfunction processUserAge(ageInput) {\n    // Convert input to number\n    const age = parseInt(ageInput);\n    \n    // Check if it's a valid age\n    if (isNaN(age)) {\n        throw new Error(\"Age must be a number\");\n    }\n    if (age &lt; 0 || age &gt; 150) {\n        throw new Error(\"Age must be between 0 and 150\");\n    }\n    \n    return age;\n}\n\n// Usage with error handling:\ntry {\n    const userAge = processUserAge(\"25\");  // Valid\n    console.log(`User is ${userAge} years old`);\n} catch (error) {\n    console.error(`Invalid age: ${error.message}`);\n}\nGraceful degradation provides backups when things fail:\nasync function getUserProfilePicture(userId) {\n    try {\n        // Try to get image from fast CDN first\n        return await fetchFromCDN(userId);\n    } catch (cdnError) {\n        try {\n            // CDN failed, try backup storage\n            return await fetchFromBackupStorage(userId);\n        } catch (backupError) {\n            // Both failed, return default image\n            return getDefaultAvatar();\n        }\n    }\n}\n\n\nSetting Up Your Debugger\nDebuggers let you pause your program and inspect what’s happening step by step.\nVS Code setup: 1. Press Ctrl+Shift+D (Run and Debug view) 2. Click “create a launch.json file” 3. Choose your language (JavaScript, Python, etc.) 4. VS Code creates a configuration file for debugging\nBrowser Developer Tools: - Press F12 to open - Console tab: See error messages and run JavaScript commands - Sources tab: Set breakpoints and step through code - Network tab: See API calls and responses\n\n\nSetting Breakpoints\nBreakpoints pause your program so you can examine the current state.\nIn your code (JavaScript):\nfunction calculateTotal(items) {\n    let total = 0;\n    \n    debugger; // Program pauses here when debugger is open\n    \n    for (let item of items) {\n        total += item.price;\n        console.log(`Added ${item.name}: $${item.price}, total: $${total}`);\n    }\n    \n    return total;\n}\nIn your IDE: - Click in the left margin next to line numbers - Red dot = active breakpoint (program will pause here) - Gray dot = disabled breakpoint\n\n\nInspecting Your Changes\nWhen your program is paused at a breakpoint, you can:\n\nView variables: See current values of all variables in scope\nStep through code: Execute one line at a time to see what happens\nCall stack: See the chain of function calls that led to this point\nConsole commands: Type commands to test things in the current context\n\nDebugging workflow: 1. Reproduce the bug: Make it happen consistently 2. Add breakpoints: At the start of the problematic function 3. Run with debugger: Step through line by line 4. Check your assumptions: Are variables what you expect? 5. Find the problem: Where does the code do something unexpected? 6. Fix and test: Make the change and verify it works",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#design-principles",
    "href": "08-software-engineering.html#design-principles",
    "title": "SWE Principles",
    "section": "Design Principles",
    "text": "Design Principles\n\nDRY (Don’t Repeat Yourself)\nDRY means each piece of knowledge in your system should exist in exactly one place. When you copy and paste code, you create maintenance problems.\nBad example (lots of repetition):\n// Three similar functions with duplicated logic\nfunction calculateStudentPrice(basePrice) {\n    return basePrice * 0.9; // 10% discount\n}\n\nfunction calculateSeniorPrice(basePrice) {\n    return basePrice * 0.85; // 15% discount  \n}\n\nfunction calculateMilitaryPrice(basePrice) {\n    return basePrice * 0.8; // 20% discount\n}\nProblem: If you need to change how discounts work, you have to update three places. Easy to miss one and create bugs.\nGood example (DRY approach):\n// One function handles all discount types\nconst DISCOUNT_RATES = {\n    student: 0.10,\n    senior: 0.15,\n    military: 0.20,\n    regular: 0.00\n};\n\nfunction calculateDiscountedPrice(basePrice, customerType) {\n    const discountRate = DISCOUNT_RATES[customerType] || 0;\n    return basePrice * (1 - discountRate);\n}\n\n// Usage examples:\nconst studentPrice = calculateDiscountedPrice(100, 'student');   // $90\nconst seniorPrice = calculateDiscountedPrice(100, 'senior');     // $85\nconst regularPrice = calculateDiscountedPrice(100, 'regular');   // $100\nBenefits: One place to update discount logic, easy to add new customer types, less chance for bugs.\n\n\nCommit Often and Frequently\nRegular git commits create a detailed project history and make it easy to track down when bugs were introduced.\nCommit frequency guidelines: - Too frequent: Every line change (clutters history) - Too infrequent: Once per week (hard to track down problems) - Just right: Complete logical units of work (features, bug fixes, improvements)\nWhat makes a good commit: - Atomic: Contains one complete change - Working: Code compiles and tests pass - Descriptive: Message clearly explains what changed\n\n\nDocumentation\nGood documentation saves time for everyone who works with your code, including future you.\nFunction documentation example:\n/**\n * Calculates compound interest on an investment.\n * \n * @param {number} principal - Starting amount of money ($)\n * @param {number} rate - Annual interest rate (as decimal: 0.05 = 5%)\n * @param {number} time - Number of years to invest\n * @param {number} [compoundsPerYear=1] - How often interest compounds (optional, defaults to 1)\n * @returns {number} Final amount after compound interest\n * \n * @example\n * // $1000 invested for 2 years at 5% annual rate, compounded quarterly\n * const result = calculateCompoundInterest(1000, 0.05, 2, 4);\n * console.log(result); // 1103.81\n */\nfunction calculateCompoundInterest(principal, rate, time, compoundsPerYear = 1) {\n    return principal * Math.pow((1 + rate / compoundsPerYear), (compoundsPerYear * time));\n}\nTypes of documentation: - Inline comments: Explain complex or non-obvious code - Function docs: Purpose, parameters, return values, examples - README files: Project overview, setup instructions, how to use - API docs: For interfaces other developers will use\nWhen to document: - Complex algorithms or business logic - Functions that others will use - Unusual or non-standard approaches - Setup and configuration steps\n\n\nSimple is Better than Complex\nSimplicity makes code easier to understand, debug, and maintain. Always choose the simpler solution when it works just as well.\nComplex approach (hard to understand):\n// What does this function do? Hard to tell at a glance.\nfunction f(x, y, z = null) {\n    return !z ? x : z &lt; 0 ? y : z &gt; 0 ? x + y : x * y;\n}\nSimple approach (clear intent):\nfunction calculatePrice(basePrice, extraFee, operation = null) {\n    // No operation specified: return base price\n    if (operation === null) {\n        return basePrice;\n    }\n    \n    // Negative operation: return just the extra fee\n    if (operation &lt; 0) {\n        return extraFee;\n    }\n    \n    // Positive operation: add base price and extra fee\n    if (operation &gt; 0) {\n        return basePrice + extraFee;\n    }\n    \n    // Zero operation: multiply base price by extra fee\n    return basePrice * extraFee;\n}\nStrategies for simplicity: - Descriptive names: calculateUserAge() instead of calc() - Small functions: Each function does one clear thing - Avoid clever tricks: Code should be obvious, not impressive - Standard patterns: Use common approaches rather than inventing new ones",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "08-software-engineering.html#a-note-on-ai",
    "href": "08-software-engineering.html#a-note-on-ai",
    "title": "SWE Principles",
    "section": "A Note on AI",
    "text": "A Note on AI\nAI tools like ChatGPT and GitHub Copilot can significantly speed up development, but they need careful oversight to maintain code quality.\nAI strengths: - Generates boilerplate code quickly - Follows established patterns - Explains complex concepts\n- Suggests solutions to common problems - Creates initial test cases\nAI limitations and how to handle them:\n1. Code duplication - AI often repeats similar code:\n// AI might generate repetitive functions:\nfunction validateEmail(email) { /* validation code */ }\nfunction validatePassword(pass) { /* similar validation code */ }\nfunction validateUsername(user) { /* similar validation code */ }\n\n// You should refactor to:\nfunction validateInput(input, type) { /* unified validation */ }\n2. Missing context - AI doesn’t understand your specific codebase:\n// AI suggestion might ignore your existing utilities:\nfunction formatDate(dateString) {\n    const date = new Date(dateString);\n    return date.toLocaleDateString();\n}\n\n// But you already have: utils/dateHelper.js with formatDate()\n// Better to use existing code for consistency\n3. Security issues - Always review for vulnerabilities:\n// AI might suggest unsafe patterns:\nfunction getUserData(userId) {\n    const query = `SELECT * FROM users WHERE id = ${userId}`; // SQL injection risk!\n    return database.query(query);\n}\n\n// Always use parameterized queries:\nfunction getUserData(userId) {\n    const query = 'SELECT * FROM users WHERE id = ?';\n    return database.query(query, [userId]);\n}\nBest practices with AI:\n\nAlways review generated code - Treat it as a first draft, not final solution\nAsk follow-up questions: “Can this be simplified?” or “Is this redundant with existing code?”\nTest thoroughly - AI code may not handle edge cases\nCheck for patterns - Ensure consistency with your existing codebase\nValidate security - Review for common vulnerabilities\n\nExample AI workflow:\nYou: \"Create a function to validate user registration data\"\nAI: [generates code]\nYou: \"Please check if this duplicates any existing validation in my codebase\"\nAI: [reviews and suggests using existing validators]\nYou: \"Add error handling and tests for edge cases\"\nAI: [improves the code with proper error handling]\nRemember: AI is a powerful assistant that can make you more productive, but it cannot replace good engineering judgment. Use it to augment your skills, not replace your thinking.\n\nBy following these principles and practices, you’ll develop the mindset and skills necessary to write high-quality code. Remember that becoming proficient takes time and practice, so be patient with yourself as you learn and apply these concepts in your own projects.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>SWE Principles</span>"
    ]
  },
  {
    "objectID": "09-ai-dev-platforms.html",
    "href": "09-ai-dev-platforms.html",
    "title": "AI Dev Tools",
    "section": "",
    "text": "Claude Code\nModern AI development tools have completely transformed what it means to build digital products. Historically, taking a product from idea to a working prototype could take weeks or even months, requiring large teams and specialized skills. Today, with the rise of AI-powered coding assistants, no-code platforms, and rapid prototyping tools, a motivated person with basic technical knowledge, and a willingness to get their hands dirty, can make significant progress in a single evening. The barrier to entry has never been lower, and the speed of experimentation has never been higher.\nThink of AI development tools as power tools, they can dramatically speed up what you can build and how fast you can build it. But just like real power tools, they aren’t magic. They still require skill, care, and good judgment to use effectively, and in the wrong hands they can create more problems than they solve.\nSeveral of the leading AI dev tools are discussed next.\nClaude Code is Anthropic’s coding assistant that runs in your terminal. You talk to it in plain English (“build me a simple landing page with an email capture”), and it creates/edits files, runs commands, and helps you prototype end-to-end—front-end, back-end, docs, and even quick data tasks. Think of it as a teammate who can both generate and execute code directly in your project folder.\nClaude Code is used directly from the terminal but many users find it more intuitive to use it within a familiar IDE like VS code.\nClaude Code: A Highly Agentic Coding Assistant",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>AI Dev Tools</span>"
    ]
  },
  {
    "objectID": "09-ai-dev-platforms.html#windsurf",
    "href": "09-ai-dev-platforms.html#windsurf",
    "title": "AI Dev Tools",
    "section": "Windsurf",
    "text": "Windsurf",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>AI Dev Tools</span>"
    ]
  },
  {
    "objectID": "09-ai-dev-platforms.html#cursor",
    "href": "09-ai-dev-platforms.html#cursor",
    "title": "AI Dev Tools",
    "section": "Cursor",
    "text": "Cursor\nCursor is an AI-powered code editor—think of it as VS Code with a coding assistant built right in. It’s designed so you can talk to it in natural language and have it write, edit, explain, or debug code directly in your project, without having to copy-paste into ChatGPT or another tool.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>AI Dev Tools</span>"
    ]
  },
  {
    "objectID": "10-build-feedback-1.html",
    "href": "10-build-feedback-1.html",
    "title": "Build Session 1",
    "section": "",
    "text": "Time to focus entirely on advancing your product, apply concepts from previous lectures, make design decisions, and work on your prototype to move it closer to a usable solution.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Build Session 1</span>"
    ]
  },
  {
    "objectID": "11-product-metrics.html",
    "href": "11-product-metrics.html",
    "title": "Product Metrics",
    "section": "",
    "text": "Acquisition Metrics\nMeasure how people discover and start using your product.\nExamples:",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Product Metrics</span>"
    ]
  },
  {
    "objectID": "11-product-metrics.html#acquisition-metrics",
    "href": "11-product-metrics.html#acquisition-metrics",
    "title": "Product Metrics",
    "section": "",
    "text": "Traffic / Visits (organic, paid, referral)\nSign-ups or New Accounts\nCustomer Acquisition Cost (CAC)\nActivation Rate (percentage of new users who reach a key first milestone)",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Product Metrics</span>"
    ]
  },
  {
    "objectID": "11-product-metrics.html#engagement-metrics",
    "href": "11-product-metrics.html#engagement-metrics",
    "title": "Product Metrics",
    "section": "Engagement Metrics",
    "text": "Engagement Metrics\nTrack how actively and frequently people interact with your product.\nExamples:\n\nDaily / Weekly / Monthly Active Users (DAU, WAU, MAU)\nSession length & frequency\nFeature usage rates\nEngagement depth (e.g., number of actions per session)",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Product Metrics</span>"
    ]
  },
  {
    "objectID": "11-product-metrics.html#retention-metrics",
    "href": "11-product-metrics.html#retention-metrics",
    "title": "Product Metrics",
    "section": "Retention Metrics",
    "text": "Retention Metrics\nMeasure how well your product keeps users coming back over time.\nExamples:\n\nRetention rate / Churn rate\nCohort analysis (retention curves)\nRepeat usage patterns\nTime to churn",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Product Metrics</span>"
    ]
  },
  {
    "objectID": "11-product-metrics.html#monetization-metrics",
    "href": "11-product-metrics.html#monetization-metrics",
    "title": "Product Metrics",
    "section": "Monetization Metrics",
    "text": "Monetization Metrics\nReflect your ability to generate revenue from your product.\nExamples:\n\nAverage Revenue per Customer (ARPC)\nCustomer Lifetime Value (CLV)\nConversion rate from free to paid\nGross margin (percentage of revenue left after covering the direct costs of delivering your product or service)\nAnnual Recurring Revenue (ARR)",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Product Metrics</span>"
    ]
  },
  {
    "objectID": "11-product-metrics.html#customer-satisfaction-quality-metrics",
    "href": "11-product-metrics.html#customer-satisfaction-quality-metrics",
    "title": "Product Metrics",
    "section": "Customer Satisfaction & Quality Metrics",
    "text": "Customer Satisfaction & Quality Metrics\nTrack how users feel about your product and the quality of their experience.\nExamples:\n\nNet Promoter Score (NPS)\nCustomer Satisfaction Score (CSAT)\nCustomer Effort Score (CES)\nBug reports & defect rates",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Product Metrics</span>"
    ]
  },
  {
    "objectID": "11-product-metrics.html#business-strategic-impact-metrics",
    "href": "11-product-metrics.html#business-strategic-impact-metrics",
    "title": "Product Metrics",
    "section": "Business & Strategic Impact Metrics",
    "text": "Business & Strategic Impact Metrics\nLink product performance to broader business goals.\nExamples:\n\nMarket share growth\nRevenue contribution by product line\nProduct ROI\nAdoption in target segments",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Product Metrics</span>"
    ]
  },
  {
    "objectID": "12-build-feedback-2.html",
    "href": "12-build-feedback-2.html",
    "title": "Build Session 2",
    "section": "",
    "text": "Time to focus entirely on advancing your product, apply concepts from previous lectures, make design decisions, and work on your prototype to move it closer to a usable solution.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Build Session 2</span>"
    ]
  },
  {
    "objectID": "14-final-presentations.html",
    "href": "14-final-presentations.html",
    "title": "Final Presentations",
    "section": "",
    "text": "Student demos of products they have built throughout the semester.",
    "crumbs": [
      "Topics",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Final Presentations</span>"
    ]
  },
  {
    "objectID": "97-resources.html",
    "href": "97-resources.html",
    "title": "Resources",
    "section": "",
    "text": "Thought Leaders\nAakash Gupta\nLinkedIn, X, YouTube\nColin Matthews\nLinkedIn\nLenny Rachitsky\nSubstack\nPaweł Huryn\nDan Olsen\nMarty Cagan\nMelissa Perri\nX\nShreyas Doshi\nTeresa Torres\nGibson Biddle\nX",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "97-resources.html#interview-preparation",
    "href": "97-resources.html#interview-preparation",
    "title": "Resources",
    "section": "Interview Preparation",
    "text": "Interview Preparation\n\nProduct Manager interview simulator\nHow top tech companies interview product managers",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "97-resources.html#bookmarks",
    "href": "97-resources.html#bookmarks",
    "title": "Resources",
    "section": "Bookmarks",
    "text": "Bookmarks\n\nAI for PMs Roadmap",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "97-resources.html#ai-workflows",
    "href": "97-resources.html#ai-workflows",
    "title": "Resources",
    "section": "AI Workflows",
    "text": "AI Workflows\n\n\n\n\n\n\nCursor Workflow\n\n\n\n\n\nStanislav Beliaev CTO of GetFluently.App\nHow to make Cursor 10x more useful with this one system 👇\nAt Fluently (AI English Coach → https://getfluently.app) we use Cursor to streamline our development process.\nBy following these proven practices, you can ship features in hours, not days.\n→ Before using Cursor:\n• Ask Claude (or ChatGPT) to create a clear, detailed plan in markdown • Have the AI ask clarifying questions, critique its own plan, and regenerate if needed • Save this plan as “instructions. md” for easy reference during development. • Use ChatGPT to add an extra planning layer before coding by another AI, reducing errors and complexity.\n→ Workflow and incremental development:\nBreak work into small, manageable tasks or feature increments.\nUse an Edit-Test loop: 1. Write a failing test case first (TDD approach). 2. Instruct AI to write code to pass the test. 3. Run the test. 4. If it fails, AI analyzes failure and fixes code. 5. Repeat until tests pass.\nReview AI-generated changes after tests pass. Encourage AI to explain its chain of thought in prompts.\n→ Debugging\n• If stuck, ask Cursor to generate a detailed report of all files and their roles, including errors. • Use ChatGPT or Claude to analyze the report and suggest fixes. • Use tools like gitingest.com to collect all scripts, configs, and relevant files in a single page for easier AI ingestion. • Refer to the latest documentation via context7.com for up-to-date info.\n→ Cursor-specific tips\n• Use CursorRules to set broad project rules (always in AI context). Search Cursor Directory for examples. • Typical rule: Write tests → write code → run tests → update code until tests pass. • Use /Reference open editors to quickly add files to AI context. • Use cursorignore to exclude irrelevant files. • Keep context short by explicitly adding files via @. Longer context can confuse AI. • Start new chats when the context becomes too long. • Resync or reindex code frequently to keep AI up to date. • Notepads are useful for frequently used prompts.\n→ Version control and file management\n• Use Git often to commit changes regularly. • Avoid large sets of uncommitted changes. • Creating files and folders (e.g., touch, mkdir) is always acceptable. • Running tests (Vitest, PM test, NR test, build, tsc) is always allowed.\n→ Optional settings and modes\nEnable YOLO mode to have AI write tests automatically.\nUse a system prompt in “Rules for AI” in Cursor settings: • Keep answers concise and direct. • Suggest alternative solutions. • Avoid unnecessary explanations. • Prioritize technical details over generic advice.",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "97-resources.html#references",
    "href": "97-resources.html#references",
    "title": "Resources",
    "section": "References",
    "text": "References\nHow To Get The Most Out Of Vibe Coding, Y Combinator Startup School\nAll about pivoting, Y Combinator Startup School",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "98-tools.html",
    "href": "98-tools.html",
    "title": "AI Tools Overview",
    "section": "",
    "text": "Front end\nStitch by Google",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>AI Tools Overview</span>"
    ]
  },
  {
    "objectID": "98-tools.html#backend",
    "href": "98-tools.html#backend",
    "title": "AI Tools Overview",
    "section": "Backend",
    "text": "Backend\n\nSupabase",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>AI Tools Overview</span>"
    ]
  },
  {
    "objectID": "98-tools.html#no-code",
    "href": "98-tools.html#no-code",
    "title": "AI Tools Overview",
    "section": "No-Code",
    "text": "No-Code\n\nLovable\n\n\n\nV0",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>AI Tools Overview</span>"
    ]
  },
  {
    "objectID": "98-tools.html#low-code",
    "href": "98-tools.html#low-code",
    "title": "AI Tools Overview",
    "section": "Low-Code",
    "text": "Low-Code",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>AI Tools Overview</span>"
    ]
  },
  {
    "objectID": "98-tools.html#pro-code",
    "href": "98-tools.html#pro-code",
    "title": "AI Tools Overview",
    "section": "Pro-Code",
    "text": "Pro-Code\n\nWindsurf\n\n\n\nCursor\n\n\nVS Code",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>AI Tools Overview</span>"
    ]
  },
  {
    "objectID": "98-tools.html#presentations",
    "href": "98-tools.html#presentations",
    "title": "AI Tools Overview",
    "section": "Presentations",
    "text": "Presentations\n\nGamma",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>AI Tools Overview</span>"
    ]
  },
  {
    "objectID": "98-tools.html#chatbots",
    "href": "98-tools.html#chatbots",
    "title": "AI Tools Overview",
    "section": "ChatBots",
    "text": "ChatBots\n\nChatGPT\nGemini\nClaude\nPerplexity\nDeepSeek\nGrok",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>AI Tools Overview</span>"
    ]
  },
  {
    "objectID": "99-prompts.html",
    "href": "99-prompts.html",
    "title": "Prompt Library",
    "section": "",
    "text": "Architecture\nOpen ChatGPT (4o, not o1/o3/o4) and say:\n“ I’m building a [description of your product - the more detailed the better]. Use Next.js for frontend, Supabase for DB + auth.\nGive me the full architecture:\nFormat this entire document in markdown.”\nSave its output as architecture.md and throw it in an empty folder where your project will live.",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Prompt Library</span>"
    ]
  },
  {
    "objectID": "99-prompts.html#architecture",
    "href": "99-prompts.html#architecture",
    "title": "Prompt Library",
    "section": "",
    "text": "File + folder structure\nWhat each part does\nWhere state lives, how services connect",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Prompt Library</span>"
    ]
  },
  {
    "objectID": "99-prompts.html#tasks",
    "href": "99-prompts.html#tasks",
    "title": "Prompt Library",
    "section": "Tasks",
    "text": "Tasks\n“ Using that architecture, write a granular step-by-step plan to build the MVP. Each task should:\n\nBe incredibly small + testable\nHave a clear start + end\nFocus on one concern\n\nI’ll be passing this off to an engineering LLM that will be told to complete one task at a time, allowing me to test in between. ”\nSave it as tasks.md. Again, throw it in the folder.",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Prompt Library</span>"
    ]
  },
  {
    "objectID": "99-prompts.html#engineering",
    "href": "99-prompts.html#engineering",
    "title": "Prompt Library",
    "section": "Engineering",
    "text": "Engineering\nStep 3: In Cursor/Windsurf\n“ You’re an engineer building this codebase.\nYou’ve been given architecture.md and tasks.md.\n\nRead both carefully. There should be no ambiguity about what we’re building.\nFollow http://tasks.md and complete one task at a time.\nAfter each task, stop. I’ll test it. If it works, commit to GitHub and move to the next. ”\n\nInclude this as well - this is crucial:\nCODING PROTOCOL\n” Coding Instructions\n\nWrite the absolute minimum code required\nNo sweeping changes\nNo unrelated edits - focus on just the task you’re on\nMake code precise, modular, testable\nDon’t break existing functionality\nIf I need to do anything (e.g. Supabase/AWS config), tell me clearly ”\n\nThis system fixes the biggest problem with vibe coding:\nYou’re not dumping everything into the IDE and praying. You’re giving it a roadmap. You’re keeping it on rails. You stay in control.\nThis workflow lets you ship clean, testable AI-assisted code - without the spiral.\nNormally I’d ask you to follow me for the playbook but this is literally it. Good luck\nSource: vasumanmoza on X\n\n\n\n\n\n\nIcons\n\n\n\n\n\nAirBnB-style icons with ChatGPT-4o in 60 seconds 👇\nI used just ONE simple prompt to create 3D isometric illustrations that feel like Pixar vibes mixed with modern, minimal design.\nUse this prompt:\n–\nGenerate [ Your Concept ] icon with this JSON style:\n{  \n  \"icon_style\": {  \n    \"perspective\": \"isometric\",  \n    \n    \"geometry\": {  \n      \"proportions\": \"1:1 ratio canvas, with objects fitting comfortably within margins\",  \n      \"element_arrangement\": \"central dominant object, with supporting elements symmetrically or diagonally placed\"  \n    },  \n    \n    \"composition\": {  \n      \"element_count\": \"2–4 main objects\",  \n      \"spatial_depth\": \"layered to create sense of dimension and slight elevation\",  \n      \"scale_consistency\": \"uniform object scale across icon set\",  \n      \"scene_density\": \"minimal to moderate, maintaining clarity and visual focus\"  \n    },  \n    \n    \"lighting\": {  \n      \"type\": \"soft ambient light\",  \n      \"light_source\": \"subtle top-right or front-top direction\",  \n      \"shadow\": \"gentle drop shadows below and behind objects\",  \n      \"highlighting\": \"mild edge illumination to define forms\"  \n    },  \n    \n    \"textures\": {  \n      \"material_finish\": \"semi-matte to satin surfaces\",  \n      \"surface_treatment\": \"smooth with light tactile variation (e.g., wood grain, soft textures)\",  \n      \"texture_realism\": \"stylized naturalism without hyper-realistic noise\"  \n    },  \n    \n    \"render_quality\": {  \n      \"resolution\": \"high-resolution octane 3D rendering\",  \n      \"edge_definition\": \"crisp, no outlines; separation achieved via lighting and depth\",  \n      \"visual_clarity\": \"clean, readable shapes with minimal clutter\"  \n    },  \n    \n    \"color_palette\": {  \n      \"tone\": \"naturalistic with slight saturation boost\",  \n      \"range\": \"harmonious muted tones with gentle contrast\",  \n      \"usage\": \"distinct colors per object to improve identification and readability\"  \n    },  \n    \n    \"background\": {  \n      \"color\": \"hashtag#FFFFFF\",  \n      \"style\": \"pure white, flat\",  \n      \"texture\": \"none\"  \n    },  \n    \n    \"stylistic_tone\": \"premium, friendly, clean with lifestyle or service-oriented appeal\",  \n    \n    \"icon_behavior\": {  \n      \"branding_alignment\": \"neutral enough for broad applications\",  \n      \"scalability\": \"legible at small and medium sizes\",  \n      \"interchangeability\": \"part of a cohesive icon system with interchangeable subject matter\"  \n    }  \n  }  \n}\n–\nJust swap [ Your Concept ] with what you want: • “coffee shop” • “bike rental” • “co-working space”\nAnd just like that, high-end, Airbnb-style icons are ready in seconds. This might be the easiest design cheat code of 2025.",
    "crumbs": [
      "Resources",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Prompt Library</span>"
    ]
  }
]